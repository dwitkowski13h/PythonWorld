%!PS-Adobe-3.0 EPSF-3.0
%%Creator: dvips(k) 5.993 Copyright 2013 Radical Eye Software
%%Title: rysunki_2.dvi
%%CreationDate: Thu Aug 24 11:40:55 2017
%%Pages: 1
%%PageOrder: Ascend
%%BoundingBox: 40 223 557 554
%%DocumentFonts: CMMI12 CMR12 CMR17 CMSY10
%%DocumentPaperSizes: a4
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: C:\TexLive\2013\bin\win32\dvips.exe -D600
%+ rysunki_2.dvi
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2017.08.24:1140
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/dir 0 def/dyy{/dir 0 def}B/dyt{/dir 1 def}B/dty{/dir 2 def}B/dtt{/dir 3
def}B/p{dir 2 eq{-90 rotate show 90 rotate}{dir 3 eq{-90 rotate show 90
rotate}{show}ifelse}ifelse}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0
N/Ry 0 N/V{}B/RV/v{/Ry X/Rx X V}B statusdict begin/product where{pop
false[(Display)(NeXT)(LaserWriter 16/600)]{A length product length le{A
length product exch 0 exch getinterval eq{pop true exit}if}{pop}ifelse}
forall}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{
BDot}imagemask grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat
{BDot}imagemask grestore}}ifelse B/QV{gsave newpath transform round exch
round exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0
rlineto fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B
/M{S p delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}
B/g{0 M}B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p
-3 w}B/n{p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{
0 S rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 902 2014-03-30 16:23:33Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.22, 2014/02/20
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionary
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/Log { dup 1e-20 lt { pop -1e30 }{ log } ifelse } def % control the log
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/Acos2 { 2 dict begin 
  /x ED /y ED
  y abs 1.0e-20 lt { 1.0e30 } if
  x y div 
  dup dup mul neg 1 add dup 0 lt {		% arc cos needs two values x,y
  pop pop 0 }{ sqrt exch atan} ifelse 
  y 0 lt { 180 add } if
} def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def 	% Polar to Cartesian
%/Rand { rand 4294967295 div } def		% a real random number
/Rand { rand 2147483447 div } def		% a real random number between 0 and 1
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%
/startGlobal { true setglobal globaldict begin } bind def
/endGlobal { end false setglobal } bind def
/pssetRGBcolor /setrgbcolor load def
/pssetCMYKcolor /setcmykcolor load def
/pssetGraycolor /setgray load def
%
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
    %% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
    %%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
    %%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/SymbolLine {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 div cvi /n ED     				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    %% for negative SymStep we calculate the distance 
    SymStep 0 lt 
      { %XYLength SymStep div abs cvi 
        /nSym SymStep abs cvi def } 
      { /nSym XYLength SymStep div cvi def }
    ifelse
    0.5 setflat
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def
    /deltaY YLength nSym div def
    curveticks 
      { XA YA moveto }
      { XA Shift sub YA Shift sub moveto }
    ifelse 
    nSym { 
      gsave 
      curveticks 
        { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
          currentpoint translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
          Symbol show 
        }
      ifelse 
      grestore 
      deltaX deltaY rmoveto
    } repeat
    /YA YB def /XA XB def
  } repeat 
  curveticks 
    { XA YA moveto }
    { XA Shift sub YA Shift sub moveto }
  ifelse 
  gsave 
  curveticks 
    { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
      XA YA translate rotAngle rotate 
      0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
      SymbolLinewidth setlinewidth stroke
    }
    { 
      rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
    }
  ifelse 
  grestore
  pop 				% delete the mark symbol
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/DotFill {%	 on stack: dot radius
  /dotRadius ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform 
  pathbbox % llx lly urx ury of smallest bounding box
  /y2 ED /x2 ED /y1 ED /x1 ED 
  y2 y1 sub a div 2 add cvi /Ny ED
  x2 x1 sub a div 2 add cvi /Nx ED
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  /yA y1 dotRadius add CLW add def
  /xA0 x1 dotRadius add CLW add def
  Ny {
     /xA xA0 def
     Nx { 
       newpath 
       xA yA dotRadius 0 360 arc 
       SolidDot { gsave fill grestore } if 
       stroke
       xA a add /xA ED
     } repeat
     yA a add /yA ED
  } repeat
  grestore
} def
%
/PenroseFill {%	 on stack: scaling factor
  /Scale ED
%  1 exch div round /penroseFactor ED 
%  a 0 dtransform round exch round exch
%  2 copy idtransform 
%  exch Atan rotate 
%  idtransform pop /a ED 
%  .25 .25 itransform pathbbox 
%  /y2 ED 
%  a Div ceiling cvi /x2 ED /y1 ED 
%  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
gsave
  220 150 translate
  Scale dup scale
  systemdict /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
%  pop pop 
} def
%
/PenroseFillA {%  on stack: scaling factor, border color, kite color, dart color
  /Scale ED
  Scale dup scale
  /border_colour ED 
  /kite_colour ED 
  /dart_colour ED
  clip 
  newpath 
  gsave
  100 100 translate
  6 
  Scale 1 lt { 1 Scale dup add div mul cvi } if %%%%   Number of iterations
  10					%%%%   Long side length in millimeters
  /border_width { L 0.06 mul }def		%%%%   Choose the scalefactor for the borders
  /L exch 25.4 div 72 mul def		%%%%   Conversion: mm -> inches -> points
  /f{-1 5 sqrt add 2 div}bind def		%%%%   The reciprocal of the golden ratio
  /l{L f mul}bind def			%%%%   Short side length l = L*f
  /Ll{L l add}bind def			%%%%   Ll =  L + l
  /c{36 cos L mul}bind def		%%%%   c  =  L*cos(36)
  /s{36 sin L mul}bind def		%%%%   s  =  L*sin(36)
  /draw_tile { 0 0 moveto c s lineto 0 lineto gsave closepath gsave fill grestore
	     0 setlinewidth stroke grestore border_colour stroke } bind def
  /half_kite { dup dup 0 gt{ 1 sub gsave f f neg scale -36 rotate half_dart
			   Ll 0 translate 144 rotate kite grestore }
	      		 { kite_colour L draw_tile }ifelse
	     pop } bind def
  /half_dart { dup dup 0 gt{ 1 sub gsave f f scale half_kite
			   -144 rotate Ll neg 0 translate half_dart grestore }
	      		 { dart_colour l draw_tile }ifelse
  	     pop } bind def
  /kite{ gsave half_kite 1 -1 scale half_kite grestore }bind def
  border_width setlinewidth  1 setlinejoin  1 setlinecap
%  450 0 translate  
  dup f exch neg exp dup scale
  5 {kite 72 rotate } repeat stroke 
  grestore
} def
%
%
/TruchetFill { %	 on stack: scaling factor
  10 dict begin
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def
  /ha a 2 div def 
  /mha ha neg def
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if
    mha mha moveto ha mha lineto
    ha ha lineto mha ha lineto
%    closepath .1 setlinewidth stroke
    contents
  } def
  /contents{ 
    0 ha moveto ha 0 lineto
    0 mha moveto mha 0 lineto
%    1 setlinewidth stroke
  } def
  /dotiling {
    f ma mul a f a mul { 
      /i exch def
      f ma mul a f a mul { 
        /j exch def
        gsave i j translate
        tile stroke grestore
      } for
    } for
  } def
%
  /f 3 def 
  5 srand dotiling 
  end % local user dict
} def
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse  	% outer or inner dimen 
  /b ED 				% the color definition
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED  	% n 2 div on stack 
  n eq not { exch pop } if		% even numbers of points? delete one
  ] aload /Points ED 
  showpoints not { Points aload pop } if
%    { ] aload /Points ED } 
%    { n 2 mul 1 add -1 roll pop } ifelse	% delete the mark symbol 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/LineToYAxis {
  /Ox ED		% Save the x origin value 
  NArray            % all x-y pairs on stack
  n { 2 copy moveto % go to current point
    Ox exch Lineto   % line to y-axis
    pop             % delete old x-value
  } repeat
} def
%
/LineToXAxis{
  /Oy ED		% Save the y origin value 
  NArray		% all x-y pairs on stack
  n 0 eq not
    { n 1 eq { 0 0 /n 2 def } if
      ArrowA
      /n n 2 sub def
      CP 2 copy moveto pop Oy Lineto
      n { 2 copy moveto pop Oy Lineto } repeat
      CP
      4 2 roll
      ArrowB
      2 copy moveto pop Oy
      L
      pop pop } if
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if 
} def
%
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED  
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto
      Lineto pop pop closepath } ifelse 
} def
%
/SymbolPolygon {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 add /m ED
  2 copy m 2 roll				% copy last two
  m 2 div cvi /n ED    				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep Div cvi def
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def
    /deltaY YLength nSym Div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
%    XB Shift sub YB Shift sub moveto Symbol show
    /YA YB def /XA XB def
  } repeat 
  pop	% delete the mark symbol
} def
%
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/CurvePath { 
  %% for negative SymStep we calculate the distance 
  SymStep 0 lt { gsave PathLength SymStep div abs /SymStep ED grestore } if
  0.5 setflat
  flattenpath /z 0 def /z0 0 def
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    curveticks 
      { x1 y1 translate startAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke      
      }
      { startAngle rotate Symbol show }
    ifelse 
    grestore /z0 z def }
  { /y ED /x ED PathLength@ z z0 sub SymStep ge {
      x Shift sub y Shift sub moveto 
      gsave 
      curveticks 
        { y yOld sub x xOld sub Atan 180 sub CorrAngle sub /rotAngle ED  
          x y translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
          Symbol show 
        }
      ifelse 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} %% the lineto part
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave
    curveticks 
      { y yOld sub x xOld sub Atan 180 sub /rotAngle ED  
        x y translate rotAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke
      }
      { 
        x Shift sub y Shift sub moveto 
        rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
        Symbol show 
      }
    ifelse 
    grestore
  }
  pathforall 
%  curveticks 
%   { gsave 
%     x y translate rotAngle rotate 
%     0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
%     SymbolLinewidth setlinewidth stroke grestore
%   } if
  z 
} def
%
/OpenSymbolCurve { 
  OpenCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/AltOpenSymbolCurve { 
  AltCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/ClosedSymbolCurve { 
  ClosedCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/CalcBezierSpline {%  Christoph Bersch
  10 dict begin
  /getX { Points exch 2 mul get } def
  /getY { Points exch 2 mul 1 add get } def
  /n Points length 1 sub 2 idiv def
  /GetFirstControlPoints {
    /x n array def
    /tmp n array def
    /b 2 def
    x 0 rhs 0 get b div put
    1 1 n 1 sub {
      /i exch def
      tmp i 1 b div dup 4 1 roll put
      i n 1 sub lt { 4 }{ 3.5 } ifelse exch sub /b exch def
      x i rhs i get x i 1 sub get sub b div put
    } for
    1 1 n 1 sub {
      n exch sub
      dup dup x exch 1 sub 2 copy 6 2 roll
      get 3 1 roll tmp exch get
      exch x exch get mul sub
      put	
    } for
    x
  } def
  % 
  n 1 eq {
    0 getX 2 mul 1 getX add 3 div
    0 getY 2 mul 1 getY add 3 div
    exch dup 3 1 roll 2 mul 0 getX sub
    exch dup 3 1 roll 2 mul 0 getY sub
    [ 0 getX 0 getY 7 3 roll 1 getX 1 getY ] /outPoints exch def
  } {
    /outPoints 6 n mul 2 add array def
    0 1 n {
      dup dup 6 mul dup 1 add
      outPoints exch 5 -1 roll getY put
      outPoints exch 3 -1 roll getX put
    } for
    /rhs n array def
    1 1 n 2 sub {
      rhs exch dup dup getX 4 mul exch 1 add getX 2 mul add put
    } for
    rhs 0 0 getX 1 getX 2 mul add put
    rhs n 1 sub dup getX 8 mul n getX add 2 div put
    GetFirstControlPoints
    1 1 n 2 sub {
      rhs exch dup dup getY 4 mul exch 1 add getY 2 mul add put
    } for
    rhs 0 0 getY 1 getY 2 mul add put
    rhs n 1 sub dup getY 8 mul n getY add 2 div put
    GetFirstControlPoints
    0 1 n 1 sub {
      /i exch def
      2 copy
      i get outPoints 6 i mul 3 add 3 -1 roll put
      i get outPoints 6 i mul 2 add 3 -1 roll put
      2 copy
      i n 1 sub lt {
        i 1 add get i 1 add getY 2 mul exch sub outPoints 6 i mul 5 add 3 -1 roll put
        i 1 add get i 1 add getX 2 mul exch sub outPoints 6 i mul 4 add 3 -1 roll put
      }{
        n 1 sub get n getY add 2 div outPoints 6 n 1 sub mul 5 add 3 -1 roll put
        n 1 sub get n getX add 2 div outPoints 6 n 1 sub mul 4 add 3 -1 roll put
      } ifelse
    } for
    pop pop
  } ifelse
  outPoints
  end
} def
/Spline {
  /showpoints ED
  counttomark 2 div dup cvi /n ED
  n eq not { exch pop } if
  ] /Points ED
  n 1 gt {
    CalcBezierSpline
    mark exch aload pop
    ArrowA
    n 2 sub {
      6 2 roll 4 2 roll curveto
    } repeat
    6 2 roll 4 2 roll ArrowB curveto
  } if
} def
/OpenSymbolSpline {
  Spline
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def

%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/OpenSymbolBezier { 
  OpenBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/ClosedSymbolBezier { 
  /f ED				 % save showpoints value 
  2 copy /yEnd ED /xEnd ED
  counttomark -2 roll 2 copy /yStart ED /xStart ED
  counttomark 2 roll
  f
  ClosedBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED % 				psk@gridlabels in pt
  /c ED % 				{ \pst@usecolor\psgridlabelcolor }
  /n ED % 				psk@griddots
  cvi dup 1 lt { pop 1 } if 
  /s ED % 				\psk@subgriddiv
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if %	\pst@number\psyunit abs
  /dx ED dy div round dy mul %		\pst@number\psxunit abs
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
/Ellipse { 
  /rotAngle ED
  /mtrx CM def 
  T 
  rotAngle rotate
  scale 0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput {
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  5 dict begin
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
  end
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 902 2014-03-30 16:23:33Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.05, 2014/03/30
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.13
%
% 09/2011 DR factorial with ! added
%
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF|P!
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P|P!
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { dup 33 eq%% is there a ! DR 09/2011
      { pop 1 add NextNonBlankChar pop EvalFactorial }
      { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower }
      ifelse
      IsEndingFactor { pop exit } if } loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalFactorial {% DR 09/2011
  /ExpressionVector ExpressionVector aload length
  /fact cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {%
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for factorial ! only cst => null derivative
/EvalFactorial {% DR 09/2011
  4 index (0) eq
  { (0) mark 8 -2 roll  cleartomark 2 index 7 index dup 4 index exch sub getinterval exch 6 2 roll }
  { DERIVATIVE_ENGINE_ERROR_no_variable_in_factorial } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { DERIVATIVE_ENGINE_ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_floor {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_EXP {%
  PreCommonFunc
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { DERIVATIVE_ENGINE_ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/! { Fact } bind def
end
%
% END pst-algparser.pro

%%EndProcSet
%%BeginProcSet: pst-tools.pro 0 0
% $Id: pst-tools.pro 842 2013-10-26 10:25:41Z herbert $
%
%% PostScript tools prologue for pstricks.tex.
%% Version 0.04, 2013/10/26
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
/Pi2 1.57079632679489661925640 def
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
/ps@ReverseOrderOfPoints { % on stack [P1 P2 P3 ...Pn]=>[Pn,Pn-1,...,P2,P1]
  5 dict begin       % all local
  aload length /n ED % number of coors
  n 2 div cvi /m ED  % number of Points
  /n1 n def
  m { n1 2 roll /n1 n1 2 sub def } repeat
  n array astore
  end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def

%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort { % on stack must be an array [ ... ]
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a % return the sorted array
end
} def
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
/rightTrim { % on stack the string and the character number to be stripped  
  /charNo exch def
  dup
  length 1 sub -1 0 { 
    /i exch def dup i get charNo ne { exit } if 
  } for
  0 i 1 add getinterval
  dup length string copy
} bind def  % leaves the stripped string on the stack

/psStringwidth /stringwidth load def
/psShow /show load def

%/stringwidth{ 32 rightTrim psStringwidth } bind def

%/show { 32 rightTrim psShow } bind def
%-----------------------------------------------------------------------------%

/pgffunctions {
    /pgfsc{}bind def% stroke color is empty by default
    /pgffc{}bind def% fill color is empty by default
    /pgfstr{stroke}bind def%
    /pgffill{fill}bind def%
    /pgfeofill{eofill}bind def%
    /pgfe{a dup 0 rlineto exch 0 exch rlineto neg 0 rlineto closepath}bind def% rectangle
    /pgfw{setlinewidth}bind def% setlinewidth
    /pgfs{save pgfpd 72 Resolution div 72 VResolution div neg scale 
      magscale{1 DVImag div dup scale}if 
      pgfx neg pgfy neg translate pgffoa .setopacityalpha}bind def% save
    /pgfr{pgfsd restore}bind def %restore
    userdict begin%
    /pgfo{pgfsd /pgfx currentpoint /pgfy exch def def @beginspecial}bind def %open
    /pgfc{newpath @endspecial pgfpd}bind def %close
    /pgfsd{globaldict /pgfdelta /delta where {pop delta} {0} ifelse put}bind def% save delta
    /pgfpd{/delta globaldict /pgfdelta get def}bind def % put delta
    /.setopacityalpha where {pop} {/.setopacityalpha{pop}def} ifelse % install .setopacityalpha 
    /.pgfsetfillopacityalpha{/pgffoa exch def
      /pgffill{gsave pgffoa .setopacityalpha fill 1 .setopacityalpha newpath fill grestore newpath}bind def
      /pgfeofill{gsave pgffoa .setopacityalpha eofill 1 .setopacityalpha newpath eofill grestore newpath}bind def}bind def
    /.pgfsetstrokeopacityalpha{/pgfsoa exch def /pgfstr{gsave pgfsoa .setopacityalpha stroke grestore newpath}bind def}bind def
    /pgffoa 1 def
    /pgfsoa 1 def
    end
} def
%-----------------------------------------------------------------------------%
% END pst-tools.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 801 2013-07-09 18:10:41Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2009/06/16
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
%  /FontBBox [-571.5 -742.5 571.5 742.5] def % changed to next line 20060616 hv
  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def
%
end
/PSTricksDotFont exch definefont pop
%
%% end

%%EndProcSet
%%BeginProcSet: pst-node.pro 0 0
% $Id: pst-node.pro 876 2014-01-28 15:03:13Z herbert $
%%
%% PostScript prologue for pst-node.tex.
%% Version 1.15, 2014/01/27.
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%%%%  EMPTY lines are not aload!!! Problem with pst-eps -> \par
%
%
tx@Dict begin 			% from main pstricks dict
 /T /translate load def 
 /CP /currentpoint load def 
% /startGlobal { true setglobal globaldict begin } bind def
% /endGlobal { end false setglobal } bind def
end
/tx@NodeDict 400 dict def tx@NodeDict begin
/NewNode { % on stack: { x y } boolean N@name type InitXnode 
  gsave 
  NodeScale                     % a bugfix for xelatex, it's empty for dvips
  /next exch def 		% { x y } boolean N@name type  
  dict dup 			% { x y } boolean N@name dict dict
  3 1 roll def 			% { x y } boolean dict N@name dict def
  exch { dup 3 1 roll def } if  % { x y } dict boolean
  begin 			% { x y } dict begin
  tx@Dict begin 
    STV CP T exec 		% set scaling
  end 
  /NodeMtrx CM def 		% save CM
  next 				% InitXNode
  end
  grestore 
} def
%
/InitPnode { 
  /Y ED /X ED 
  /NodePos { NodeSep Cos mul NodeSep Sin mul } def
} def
%
/InitCnode { 
  /r ED /Y ED /X ED 
  /NodePos { NodeSep r add dup Cos mul exch Sin mul } def 
} def
%
/GetRnodePos { 
  Cos 0 gt { /dx r NodeSep add def } { /dx l NodeSep sub def } ifelse 
  Sin 0 gt { /dy u NodeSep add def } { /dy d NodeSep sub def } ifelse 
  dx Sin mul abs dy 
  Cos mul abs gt { dy Cos mul Sin div dy } { dx dup Sin mul Cos Div } ifelse 
} def
%
/InitRnode { 
  /Y ED /X ED X sub /r ED /l X neg def Y add neg /d ED Y sub /u ED 
  /NodePos { GetRnodePos } def 
} def
%
/DiaNodePos { 
  w h mul w Sin mul abs h Cos mul abs add Div NodeSep add dup
  Cos mul exch Sin mul 
} def
%
/TriNodePos { 
  Sin s lt 
    { d NodeSep sub dup Cos mul Sin Div exch } 
    { w h mul w Sin mul h Cos abs mul add Div 
      NodeSep add dup Cos mul exch Sin mul 
    } ifelse 
} def
%
/InitTriNode { 
  sub 2 div exch 
  2 div exch 
  2 copy T 
  2 copy 4 index index /d ED 
  pop pop pop pop 
  -90 mul rotate 
  /NodeMtrx CM def 
  /X 0 def /Y 0 def 
  d sub abs neg /d ED 
  d add /h ED 
  2 div h mul h d sub Div /w ED 
  /s d w Atan sin def 
  /NodePos { TriNodePos } def 
} def
%
/OvalNodePos { 
  /ww w NodeSep add def 
  /hh h NodeSep add def 
  Sin ww mul Cos hh mul Atan dup cos ww mul exch sin hh mul 
} def
%
/GetCenter { begin X Y NodeMtrx transform CM itransform end } def
%
/XYPos { 
  dup sin exch cos Do 
  /Cos ED /Sin ED /Dist ED 
  Cos 0 gt 
    { Dist Dist Sin mul Cos div }
    { Cos 0 lt 
      { Dist neg Dist Sin mul Cos div neg }
      { 0 Dist Sin mul } ifelse 
    } ifelse 
  Do 
} def
%
/GetEdge {
  dup 0 eq 
    { pop begin 1 0 NodeMtrx dtransform 
      CM idtransform 
      exch atan sub 
      dup 
      sin /Sin ED 
      cos /Cos ED 
      /NodeSep ED 
      NodePos NodeMtrx dtransform CM idtransform end }
    { 1 eq {{exch}} {{}} ifelse /Do ED pop XYPos } ifelse 
} def
%
/AddOffset { 
  1 index 0 eq 
    { pop pop } 
    { 2 copy 5 2 roll cos mul add 4 1 roll sin mul sub exch } ifelse 
} def
%
/GetEdgeA { 
  NodeSepA AngleA NodeA NodeSepTypeA GetEdge 
  OffsetA AngleA AddOffset 
  yA add /yA1 ED 
  xA add /xA1 ED 
} def
%
/GetEdgeB { 
  NodeSepB AngleB NodeB NodeSepTypeB GetEdge 
  OffsetB AngleB AddOffset 
  yB add /yB1 ED 
  xB add /xB1 ED 
} def
%
/GetArmA { 
  ArmTypeA 0 eq 
    { /xA2 ArmA AngleA cos mul xA1 add def 
      /yA2 ArmA AngleA sin mul yA1 add def } 
    { ArmTypeA 1 eq {{exch}} {{}} ifelse 
      /Do ED 
      ArmA AngleA XYPos OffsetA AngleA AddOffset 
      yA add /yA2 ED 
      xA add /xA2 ED } ifelse 
} def
%
/GetArmB { 
  ArmTypeB 0 eq 
    { /xB2 ArmB AngleB cos mul xB1 add def 
      /yB2 ArmB AngleB sin mul yB1 add def } 
    { ArmTypeB 1 eq {{exch}} {{}} ifelse 
      /Do ED
      ArmB AngleB XYPos OffsetB AngleB AddOffset 
      yB add /yB2 ED 
      xB add /xB2 ED } ifelse 
} def
%
/InitNC { 
  /b ED /a ED % second and first node
  /NodeSepTypeB ED /NodeSepTypeA ED 
  /NodeSepB ED /NodeSepA ED 
  /OffsetB ED /OffsetA ED 
  tx@NodeDict a known tx@NodeDict b known and dup { 
    /NodeA a load def 
    /NodeB b load def 
    NodeA GetCenter /yA ED /xA ED 
    NodeB GetCenter /yB ED /xB ED } if 
} def
%
/LPutLine { 
  4 copy 
  3 -1 roll sub neg 3 1 roll sub Atan /NAngle ED 
  1 t sub mul 
  3 1 roll 1 t sub mul 
  4 1 roll t mul add /Y ED 
  t mul add /X ED 
} def
%
/LPutLines { 
  mark LPutVar counttomark 2 div 1 sub /n ED 
%  t floor dup n gt 
  t floor dup n ge 		% to allow npos<= hv 2008-08-14
  { pop n 1 sub /t 1 def } { dup t sub neg /t ED } ifelse 
  cvi 2 mul { pop } repeat 
  LPutLine 
  cleartomark 
} def
%
/BezierMidpoint { 
  /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED /y0 ED /x0 ED /t ED 
  /cx x1 x0 sub 3 mul def 
  /cy y1 y0 sub 3 mul def 
  /bx x2 x1 sub 3 mul cx sub def 
  /by y2 y1 sub 3 mul cy sub def 
  /ax x3 x0 sub cx sub bx sub def 
  /ay y3 y0 sub cy sub by sub def 
  ax t 3 exp mul bx t t mul mul add 
  cx t mul add x0 add ay t 3 exp mul 
  by t t mul mul add cy t mul add
  y0 add 3 ay t t mul mul mul 2 
  by t mul mul add cy add 3 ax t t mul mul mul 
  2 bx t mul mul add cx add atan /NAngle ED 
  /Y ED /X ED 
} def
%
/HPosBegin { yB yA ge { /t 1 t sub def } if /Y yB yA sub t mul yA add def
} def
%
/HPosEnd { /X Y yyA sub yyB yyA sub Div xxB xxA sub mul xxA add def
           /NAngle yyB yyA sub xxB xxA sub Atan def 
} def
/HPutLine { HPosBegin /yyA ED /xxA ED /yyB ED /xxB ED HPosEnd  } def
%
/HPutLines { HPosBegin yB yA ge 
  { /check { le } def } { /check { ge } def } ifelse 
  /xxA xA def 
  /yyA yA def 
  mark xB yB LPutVar 
    { dup Y check { exit } { /yyA ED /xxA ED } ifelse } 
  loop 
  /yyB ED /xxB ED cleartomark HPosEnd 
} def
%
/VPosBegin { 
  xB xA lt { /t 1 t sub def } if /X xB xA sub t mul xA add def
} def
%
/VPosEnd { /Y X xxA sub xxB xxA sub Div yyB yyA sub mul yyA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/VPutLine { VPosBegin /yyA ED /xxA ED /yyB ED /xxB ED VPosEnd  } def
/VPutLines { VPosBegin xB xA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { 1 index X check {
exit } { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark
VPosEnd  } def
/HPutCurve { gsave newpath /SaveLPutVar /LPutVar load def LPutVar 8 -2
roll moveto curveto flattenpath /LPutVar [ {} {} {} {} pathforall ] cvx
def grestore exec /LPutVar /SaveLPutVar load def 
} def
%
/NCCoor { 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def
  GetEdgeA GetEdgeB 
  /LPutVar [ xB1 yB1 xA1 yA1 ] cvx def 
  /LPutPos { LPutVar LPutLine } def 
  /HPutPos { LPutVar HPutLine } def 
  /VPutPos { LPutVar VPutLine } def 
  LPutVar 
} def
%
/NCLine { 
  NCCoor 
  tx@Dict begin 
  ArrowA CP 4 2 roll 
  ArrowB 
  lineto pop pop
  end 
} def
%
/NCLines { 
  false NArray 
  n 0 eq 
    { NCLine } 
    { 2 copy yA sub exch xA sub Atan /AngleA ED 
      n 2 mul dup index exch index yB sub exch xB sub 
      Atan /AngleB ED 
      GetEdgeA GetEdgeB 
      /LPutVar [ xB1 yB1 n 2 mul 4 add 4 roll xA1 yA1 ] cvx def 
      mark LPutVar 
      tx@Dict begin false Line end 
      /LPutPos { LPutLines } def 
      /HPutPos { HPutLines } def 
      /VPutPos { VPutLines } def 
    } ifelse 
} def
%
/NCCurve { 
  GetEdgeA 
  GetEdgeB 
  xA1 xB1 sub yA1 yB1 sub Pyth 2 div dup 3 -1
roll mul /ArmA ED mul /ArmB ED /ArmTypeA 0 def /ArmTypeB 0 def GetArmA
GetArmB xA2 yA2 xA1 yA1 tx@Dict begin ArrowA end xB2 yB2 xB1 yB1 tx@Dict
begin ArrowB end curveto /LPutVar [ xA1 yA1 xA2 yA2 xB2 yB2 xB1 yB1 ]
cvx def /LPutPos { t LPutVar BezierMidpoint } def /HPutPos { { HPutLines
} HPutCurve } def /VPutPos { { VPutLines } HPutCurve } def } def
%
/NCAngles { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform pop 
  xB2 yB2 mtrx transform exch pop 
  mtrx itransform 
  /y0 ED /x0 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def } def
%
/NCAngle { 
  GetEdgeA GetEdgeB GetArmB 
  /mtrx AngleA matrix rotate def 
  xB2 yB2 mtrx itransform pop xA1 yA1 mtrx itransform exch pop mtrx transform
  /y0 ED /x0 ED 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA1 yA1
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCBar { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def
  xA2 yA2 mtrx itransform pop 
  xB2 yB2 mtrx itransform pop 
  sub dup 0 mtrx transform 
  3 -1 roll 0 gt 
    { /yB2 exch yB2 add def /xB2 exch xB2 add def }
    { /yA2 exch neg yA2 add def /xA2 exch neg xA2 add def } ifelse 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCDiag { 
  /lineAngle ED
  GetEdgeA GetEdgeB GetArmA GetArmB mark
  lineAngle abs 0 gt {
    /xTemp xA2 10 add def
    /yTemp yA2 lineAngle dup sin exch cos div 10 mul add def
    /dY1 yTemp yA2 sub def
    /dX1 xTemp xA2 sub def
    /dY2 yB2 yB1 sub def
    /dX2 xB2 xB1 sub def
    dX1 abs 0.01 lt {
      /m2 dY2 dX2 div def
      /xB2 xA2 def
      /yB2 xA2 xB1 sub m2 mul yB1 add def
    }{
      dX2 abs 0.01 lt {
        /m1 dY1 dX1 div def
        /xB2 xB1 def
        /yB2 xB1 xA2 sub m1 mul yA2 add def
      }{%
        /m1 dY1 dX1 div def
        /m2 dY2 dX2 div def
        /xB2 m1 xA2 mul m2 xB1 mul sub yA2 sub yB1 add m1 m2 sub div def
        /yB2 xB2 xA2 sub m1 mul yA2 add def
      } ifelse
    } ifelse
  } if
  ArmB 0 ne { xB1 yB1 } if
  xB2 yB2 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
%
%  GetEdgeA GetEdgeB GetArmA GetArmB mark 
%  ArmB 0 ne { xB1 yB1 } if
%  xB2 yB2 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end
%  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCDiagg { 
  /lineAngle ED
  GetEdgeA GetArmA 
  lineAngle abs 0 gt 
    { lineAngle }
    { yB yA2 sub xB xA2 sub Atan 180 add } ifelse 
  /AngleB ED
  GetEdgeB mark
  lineAngle abs 0 gt {
    /dY2 yA2 yA1 sub def
    /dX2 xA2 xA1 sub def
    lineAngle abs 90 eq {
      /m2 dY2 dX2 div def
      /yA2 xB xA2 sub m2 mul yA2 add def
      /xA2 xB def
    }{
      /m1 lineAngle dup sin exch cos div def % tan alpha
      dX2 abs 0.01 lt {
        /yA2 xA1 xB sub m1 mul yB add def
        /xA2 xA1 def
      }{%
        /m2 dY2 dX2 div def
        /xA2 m1 xB mul m2 xA2 mul sub yA2 add yB sub m1 m2 sub div def
        /yA2 xA2 xB sub m1 mul yB add def
      } ifelse
    } ifelse
  } if
  xB1 yB1 xA2 yA2
  ArmA 0 ne { xA1 yA1 } if
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def
  /VPutPos { VPutLines } def
%
%  GetEdgeA GetArmA 
%  yB yA2 sub xB xA2 sub Atan 180 add /AngleB ED
%  GetEdgeB 
%  mark 
%  xB1 yB1 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end 
%  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCLoop { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform loopsize add /yA3 ED /xA3 ED 
  /xB3 xB2 yB2 mtrx transform pop def 
  xB3 yA3 mtrx itransform /yB3 ED /xB3 ED 
  xA3 yA3 mtrx itransform /yA3 ED /xA3 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
% DG/SR modification begin - May 9, 1997 - Patch 1
%/NCCircle { 0 0 NodesepA nodeA \tx@GetEdge pop xA sub 2 div dup 2 exp r
%r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
%exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
%mul add dup 5 1 roll 90 sub \tx@PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
%
/NCCircle { 
  NodeSepA 0 NodeA 0 GetEdge pop 
  2 div dup 2 exp r r mul sub abs sqrt 
  atan 2 mul /a ED 
  r AngleA 90 add PtoC yA add exch xA add 
  exch 2 copy 
  /LPutVar [ 4 2 roll r AngleA ] cvx def 
  /LPutPos { 
    LPutVar t 360 mul add dup 5 1 roll 90 sub PtoC 
    3 -1 roll add 
    /Y ED add /X ED /NAngle ED
% DG/SR modification end
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
  r AngleA 90 sub a add AngleA 270 add a sub 
  tx@Dict begin 
  /angleB ED /angleA ED /r ED 
  /c 57.2957 r Div def 
  /y ED /x ED 
} def
%
/NCBox { 
  /d ED /h ED 
  /AngleB yB yA sub xB xA sub Atan def 
  /AngleA AngleB 180 add def 
  GetEdgeA GetEdgeB 
  /dx d AngleB sin mul def 
  /dy d AngleB cos mul neg def 
  /hx h AngleB sin mul neg def 
  /hy h AngleB cos mul def 
  /LPutVar [ 
    xA1 hx add yA1 hy add xB1 hx add yB1 hy add 
    xB1 dx add yB1 dy add xA1 dx add yA1 dy add ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { xB yB xA yA LPutLine } def 
  /VPutPos { HPutPos } def 
  mark 
  LPutVar tx@Dict begin false Polygon end 
} def
%
/NCArcBox { 
  /l ED neg /d ED /h ED /a ED 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def 
  /tA AngleA a sub 90 add def 
  /tB tA a 2 mul add def 
  /r xB xA sub tA cos tB cos sub Div dup 0 eq { pop 1 } if def
  /x0 xA r tA cos mul add def 
  /y0 yA r tA sin mul add def 
  /c 57.2958 r div def 
  /AngleA AngleA a sub 180 add def 
  /AngleB AngleB a add 180 add def
  GetEdgeA GetEdgeB 
  /AngleA tA 180 add yA yA1 sub xA xA1 sub Pyth c mul sub def 
  /AngleB tB 180 add yB yB1 sub xB xB1 sub Pyth c mul add def 
  l 0 eq { 
    x0 y0 r h add AngleA AngleB arc x0 y0 r d add AngleB AngleA arcn 
  }{ 
    x0 y0 translate 
    /tA AngleA l c mul add def 
    /tB AngleB l c mul sub def
    0 0 r h add tA tB arc r h add 
    AngleB PtoC r d add 
    AngleB PtoC 2 copy 
    6 2 roll l arcto 4 { pop } repeat 
    r d add tB PtoC l arcto 4 { pop } repeat 
    0 0 r d add tB tA arcn r d add 
    AngleA PtoC r h add 
    AngleA PtoC 2 copy 6 2 roll 
    l arcto 4 { pop } repeat 
    r h add tA PtoC l arcto 4 { pop } repeat 
  } ifelse 
  closepath 
  /LPutVar [ x0 y0 r AngleA AngleB h d ] cvx def 
  /LPutPos { 
    LPutVar /d ED /h ED 
    /AngleB ED /AngleA ED 
    /r ED /y0 ED /x0 ED 
    t 1 le { 
      r h add AngleA 1 t sub mul AngleB t mul add dup 90 add /NAngle ED PtoC 
    }{t 2 lt { 
        /NAngle AngleB 180 add def r 2 t sub 
        h mul t 1 sub d mul add add AngleB PtoC 
      }{ 
        t 3 lt { 
          r d add AngleB 3 t sub mul AngleA 2 t sub
          mul add dup 90 sub /NAngle ED PtoC 
        }{ 
          /NAngle AngleA 180 add def 
          r 4 t sub d mul t 3 sub h mul add add AngleA PtoC 
        } ifelse 
      } ifelse 
    } ifelse
    y0 add /Y ED x0 add /X ED 
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
} def
%
/Tfan { /AngleA yB yA sub xB xA sub Atan def GetEdgeA w xA1 xB sub yA1 yB
sub Pyth Pyth w Div CLW 2 div mul 2 div dup AngleA sin mul yA1 add /yA1
ED AngleA cos mul xA1 add /xA1 ED /LPutVar [ xA1 yA1 m { xB w add yB xB
w sub yB } { xB yB w sub xB yB w add } ifelse xA1 yA1 ] cvx def /LPutPos
{ LPutLines } def /VPutPos@ { LPutVar flag { 8 4 roll pop pop pop pop }
{ pop pop pop pop 4 2 roll } ifelse } def /VPutPos { VPutPos@ VPutLine }
def /HPutPos { VPutPos@ HPutLine } def mark LPutVar tx@Dict begin
/ArrowA { moveto } def /ArrowB { } def false Line closepath end } def
%
/LPutCoor { 
  NAngle 
  tx@Dict begin /NAngle ED end 
  gsave 
  CM STV 
  CP Y sub neg exch X sub neg exch moveto 
  setmatrix CP 
  grestore 
} def
%
/LPut { 
  tx@NodeDict /LPutPos known 
    { LPutPos } { CP /Y ED /X ED /NAngle 0 def } ifelse 
  LPutCoor  
} def
%
/HPutAdjust { 
  Sin Cos mul 0 eq 
    { 0 } 
    { d Cos mul Sin div flag not { neg } if 
      h Cos mul Sin div flag { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { r add neg }{ l add } ifelse 
  X add /X ED 
} def
%
/VPutAdjust { 
  Sin Cos mul 
  0 eq 
    { 0 }
    { l Sin mul Cos div flag { neg } if
      r Sin mul Cos div flag not { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { d add } { h add neg } ifelse 
  Y add /Y ED 
} def
%
%
end
%
% END pst-node.pro

%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/psfts{S 65781.76 div N}N/startTexFig{/psf$SavedState
save N userdict maxlength dict begin/magscale true def normalscale
currentpoint TR/psf$ury psfts/psf$urx psfts/psf$lly psfts/psf$llx psfts
/psf$y psfts/psf$x psfts currentpoint/psf$cy X/psf$cx X/psf$sx psf$x
psf$urx psf$llx sub div N/psf$sy psf$y psf$ury psf$lly sub div N psf$sx
psf$sy scale psf$cx psf$sx div psf$llx sub psf$cy psf$sy div psf$ury sub
TR/showpage{}N/erasepage{}N/setpagedevice{pop}N/copypage{}N/p 3 def
@MacSetUp}N/doclip{psf$llx psf$lly psf$urx psf$ury currentpoint 6 2 roll
newpath 4 copy 4 2 roll moveto 6 -1 roll S lineto S lineto S lineto
closepath clip newpath moveto}N/endTexFig{end psf$SavedState restore}N
/@beginspecial{SDict begin/SpecialSave save N gsave normalscale
currentpoint TR @SpecialDefaults count/ocount X/dcount countdictstack N}
N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto 0 vs rlineto hs
neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale ang rotate
rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}ifelse
scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale llx neg
lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly lineto urx
ury lineto llx ury lineto closepath clip}if/showpage{}N/erasepage{}N
/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{count ocount sub{
pop}repeat countdictstack dcount sub{end}repeat grestore SpecialSave
restore end}N/@defspecial{SDict begin}N/@fedspecial{end}B/li{lineto}B
/rl{rlineto}B/rc{rcurveto}B/np{/SaveX currentpoint/SaveY X N 1
setlinecap newpath}N/st{stroke SaveX SaveY moveto}N/fil{fill SaveX SaveY
moveto}N/ellipse{/endangle X/startangle X/yrad X/xrad X/savematrix
matrix currentmatrix N TR xrad yrad scale 0 0 1 startangle endangle arc
savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
%%BeginFont: CMSY10
%!PS-AdobeFont-1.0: CMSY10 003.002
%%Title: CMSY10
%Version: 003.002
%%CreationDate: Mon Jul 13 16:17:00 2009
%%Creator: David M. Jones
%Copyright: Copyright (c) 1997, 2009 American Mathematical Society
%Copyright: (<http://www.ams.org>), with Reserved Font Name CMSY10.
% This Font Software is licensed under the SIL Open Font License, Version 1.1.
% This license is in the accompanying file OFL.txt, and is also
% available with a FAQ at: http://scripts.sil.org/OFL.
%%EndComments
FontDirectory/CMSY10 known{/CMSY10 findfont dup/UniqueID known{dup
/UniqueID get 5096651 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /CMSY10 def
/FontBBox {-29 -960 1116 775 }readonly def
/UniqueID 5096651 def
/PaintType 0 def
/FontInfo 9 dict dup begin
/version (003.002) readonly def
/Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMSY10.) readonly def
/FullName (CMSY10) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle -14.04 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /minus put
dup 21 /greaterequal put
dup 50 /element put
dup 56 /universal put
dup 57 /existential put
dup 106 /bar put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CD06DFE1BE899059C588357426D7A0
7B684C079A47D271426064AD18CB9750D8A986D1D67C1B2AEEF8CE785CC19C81
DE96489F740045C5E342F02DA1C9F9F3C167651E646F1A67CF379789E311EF91
511D0F605B045B279357D6FC8537C233E7AEE6A4FDBE73E75A39EB206D20A6F6
1021961B748D419EBEEB028B592124E174CA595C108E12725B9875544955CFFD
028B698EF742BC8C19F979E35B8E99CADDDDC89CC6C59733F2A24BC3AF36AD86
1319147A4A219ECB92D0D9F6228B51A97C29547000FCC8A581BE543D73F1FED4
3D08C53693138003C01E1D216B185179E1856E2A05AA6C66AABB68B7E4409021
91AA9D8E4C5FBBDA55F1BB6BC679EABA06BE9795DB920A6343CE934B04D75DF2
E0C30B8FD2E475FE0D66D4AA65821864C7DD6AC9939A04094EEA832EAD33DB7A
11EE8D595FB0E543D0E80D31D584B97879B3C7B4A85CC6358A41342D70AD0B97
C14123421FE8A7D131FB0D03900B392FDA0ABAFC25E946D2251F150EC595E857
D17AE424DB76B431366086F377B2A0EEFD3909E3FA35E51886FC318989C1EF20
B6F5990F1D39C22127F0A47BC8461F3AFDF87D9BDA4B6C1D1CFD7513F1E3C3D3
93BEF764AA832316343F9FE869A720E4AA87AE76FA87A833BBC5892DE05B867F
10FA225E233BCFA9BB51F46A6DF22ADCEACC01C3CD1F54C9AEFA25E92EFAC00D
7E2BA427C25483BA42A199F4D2E43DFCE79A7156F7417ACF78E41FCA91E6C9EF
B933450D851B73A6AB6AEA7EE4C710CB5C14270D1674FA334686653793FCB31B
491E870D3C2BC654D2C1DE463EC9BA29D7371AA1078800EF93D3F66263A2EBBB
F5723697BF7448BD0D2E301544BECF497FD475B85DFEF52AF4F8F8BE445CABE6
019318806D10C5952157FF8F8286C1EE701545C8F60EFA854EAE66835A2046A6
915D395F1E0366EFE0C0391583FE001FF16D82A2E2DA5F57754A2C6F69306E36
356ECF8EFC3F1188AD6FCD2427E0580C97A5B69B4E0E09B85EEDE142F5ADD2F0
5DE51D6DB72B127412A0D57106C19CA493048A4F815129ABE767D51715B1515D
9C21067CB5BC88741B7298C83EAE36A866DFA87D8981F179B1C31292F56BBB64
3C430779468AAF07C8A8B4934E1E775FE3F35186BD1FA6EE3689C1C750678AF1
FBF9B23195A124C5C991FE670AC0C86FD39D2B07B9A319E74EFD498B45820252
720ECDF7294F7B0B137CEB86D33BFCEB8606985A3260FD669E461C8BE94216C5
D434FD8854F44EE66E5A289A9F9E32BC36AF645D53F96652602BAED418C8D726
BD04A1B4617551FE4DEF54083D414F7DCE004E6BB2DC9C2EF7CE232B254BA2C5
7DCBD36C2072ED46FF711F121A701E2284BF1B718B3164382B8F453D68FA0377
DFE106503B8401D4DB87F5402A3AC9A442FA060B0610A9524D530C7157C26B56
AC970FCC1D5655FFFFA39246E6420CF97D08ADFB7B05822679BD40C638DDF0E7
A97BFE8918B611A145AC965C203F1428812F9D340AF499B3A915B22BE798594E
0F520109FC81E452180AE45B170FF999C5FC2761C6CECD8742A5A6FC97F16743
AD4EFCC6572A6D3F3E4E330C5CB2FF6FEA48A5B64DD3DBE943BD9918D4A18E18
CBCF598AEFBB6AB3CD2CBC9BFD6099272F6543F3E532E0E21E614BD2880B1023
0AC234CB705827BF016DB84E00E8C255FDEFA0101A842929540B7B4AA8A089BD
5EFF05B72356B6BC3727817823B5CDBB1B963103000D7F2A4E2A1472FC3E614B
5CBCB6D6D784023173DEFEBFA8F9ED87EC1A0A9EE98CA59CFC964CF943DC683F
E9E00DA718C4425A705A69D99988EC6F152525C790912C2E46A2381A569424AB
54DF4798BC2D7E7A361E7991641D4B756CE2A7FF4A2848927092C59C2C4B8809
E13AB84FB6B111E680D7FB9F2FFC2C5C66B0B501E4447C2E46C10E2F6124476F
A140C404CFE2DC9E0199BF61E035CEB481D438139A9630934E541D261FFD2906
4CAD99E20655FA746AFB81EDBB5601F5FD6B1D6832A01D585E2C55053F6A7378
4DAACCAC7608DBDADAAE732D66B3E7F87E79756337C1A961E53A4651BE7C77F4
038B89C87F650C54A2A90EB7F1D525BB353F33318551EE8D84A6A83C718EA5A4
B2AC0F7306B1E095819B87015A90CA3ED739B09061782C28CDB36BA4BD5E5308
5CBB70414E4112193DAC4A1FA30996327230D1E021F3CD8115E12D239D93FFDC
B645910EB29E40D830E7BAF2DB255FD7C4E776557BB38157917D993EAC245837
A3B515147043574157B8342D829C7228CCEA843ABC89D1785A9672A5923FC4CD
2F3FF27E6FCACF84E2D3136CA2C0FD3EF1EE7354CD04C38B5FB874553646ED2D
CEDF7E362EADD04B18051F20A8FB0DE18E152385B9D05F98A3A7EF177824E246
455ABE69E2F700EB78185CCFC07E3B4C6FA301112528D977367D30D0D5D59EDE
FAEB706DDC970A9E296236C725B2B55B09B9C336B8E23CBA5FB8692D56F33B03
16294E5FC7FAA42E96395A57CE51CA8DDD77442F142E2E576B778373FB31C81C
16840BB422CA827E30A81829648BDF1CA36700EA32AD888D097C1FE0A05B2D9F
483AEE40269DF09AF0D1AD3DF80C45DDC59C2A03FBB661C79B87853737C6D352
67626B657321B16198DBD6DB98A092F17878AE4698121E1006E53D6F9B0A3BE2
3FB68828EF854A0CDBAA68B37ABCA6AD4A3D809AAF0BAB1697A81FE59C98C472
1E33CD70A75A22C249DD11D76C2575ED3370A25892A16D2FD569CDA70C130770
93F493C7D47D6F9A5424A7A542BAD726BFC3AB225DCEBBE6AC4BE006F8C7C0EA
051424B08305BF2D951AB2986AAFEA04E078CA79B399585BFF0F1ADCED02E15B
8765EB6BF6A8E4D0901EFF2C3AA104924EAD9637A35D877E0C51A3C37DA78CD4
8643C8CE6DCDDE3F116A6C2390F948E5371BEB5AD2E87B41C5F01FB5C196C436
6E256A88D082E3F46E4EFFBF605B2EFF1E9D9AD5EE4DDC323A137CD9451EDEE0
06F7D82898D71FAF2362C0FCF1F726F97F820305B7CE20728CA08C63575083A7
84BA28B7DE2B916432475510E274C12FFD1660A717F51DACFDF0A102D85224E0
D6DB607BB72569ABB8A7BC6A10354CBBC01732EFE35B72062DF269CB25EA3DE6
DC603B04C90C5912D2C38D7A5ACDCDD3F6F116D884F0D8C528F69D5D47BA20DB
0A9E585C7D8CC3C324FE8A1DF150279F7E8FB43BDB720E624E5E9918032C02CD
8020636AE5C38DA2484B7F4B34163E0D0A561B43B80E97746DC05C871AB620EC
C5D47101ECED4A7E25F291184BEF8B80024AA7BB456C1B83A907652B331DEA34
754226C39C6889EBEEFDAD081E01EF8FE47751987667836FDE4C8BB8A3FD4406
1E643B4EA37BD370734D1A2DB17C2F4B74B4ED75098B433601F75A88C9A37A05
CCB157EF6E32023BFA33973F3E655A4D58289136996FCFA61EEABD70791B6523
1FF5DE71AB8A17038923118A5EED8D59C4C58D246FFA9BB26472346B40C8741F
153D19CAFF20DD2A86C6DB89154A630FB1761929FC3F0448EE2F089C1C953E02
905BA8DE75D101A982A611056C4B237596C10951DD98BAB838B742D3CF7DE718
617DB72E5268583223E37E029D1C8FD3F1D21690151F76B76C52C725CA135CA2
8666553E863CE188BFC9B99AF56AC2DB5BFEBEB12FB563D00244EB89E478657A
98AF2E1223C1ABC25A4500E8119B86EB3C26B8A2F3505A3E5610F89B7C34E278
53FA0A54A7F46D84A35EFEC36AE660A9E3C37EE3864106702DE5AF6C45ABF64B
888A4A51323138CE77DB935576FE6B4824B6942DF80625098CE1B5B32B234F1D
052A9D6039697118A9D793793775D8729D8574A2E74D7109C7B7E23BC5E2E87A
CA8E019203952A4892544E1AD3D4EDD22971611358AB230E9A2ABDF00A288501
A01B67C42B33F6B78C39562DB50F4663B922D9BE0D8A150311AE44B83C1F129F
07337323E9A23211EE58E16043E127C6F9574019179F5635648A011266677B56
B5D0201A4E1470B952A1579B57AB2329CD4C615395023C653F784D36B5EE3672
10D191F29EA508CE84763CA4CE7C2C5229E38E241255A5CABCD6C7CBAED901A2
CA53B5E24111921CDDF83578D33D463D70EDACA0E470D8F592303FB6BFD68B4D
3F3BE2D7C5EC8BBF10C90111A33E205F2649B56E8443F6FAA6C721C66575AE12
D4C40F1F46CF9E9DA675AB5D5840D938780CD9E4AD6736ECBEB6A4397613586F
849B51048AC5F9405E03E14540A5E5582F61CDCDB57EDDF95A8C6705F433EE16
648F098C03DED8A2AD94AE3DE202D629B9422ABB031318D48F2C85F9DBFA17BE
84708AA3B6C9F81F4508F7A5CB7B6646AB8722ECF817877B77D473F577556DAA
2BA0ABACFCF5DEA7498C47328E873019A956FBB250FD9D8885D21D368FA70CBD
2709D2DA44EE7A9869963EAB48789541906DE49FAE785ECE1F18A22C7E7ED204
9768896B78E9EB7A2BD6EEC1B26083940656ECD689D92942CC8AF05CBF82AED0
B45A7DF4DD7AA6526FB597322560B9ED3087A65B5EEF1371C328A021411BFE3B
D9B5088B2F1AAE381FFED52D2D1E02CD0DA78683E3B06171CBE94BE9760005D7
135893D7CC2DB097F6AC664D9594CF1C650F84DA80D2EDE04802DBA33CE3DAFE
EB7A37E8AEFA4FDA6252FF21E8673DD98E67124D5DBC7BACF361E57077B71939
C1D1FB923E4E35C075CD1BCBE0E80DAEA1320D55B43EAB45D9B26C366B278782
7519FDC482D98839BF0DF2E7C3A56A1C1A3FC0E57A75CA414F6536C1FE8EB7A0
4ADFEE3BEDA0F53BE8CF5F64230784A797133E8CD46BCCB3BF38BCE38A73CCE2
9E073ADE792F7128231DDD1F63E6156ADB2609C200837C2E8A2D93D2A7BC9171
050C709A71E44E32B1B03C92EB5CF1D3BAB1C38E027DC4ED9AED633D98CD7486
3F773ACF8AE332631CF2ABE6D606607593FE862ADE31803964E3F4DC3CE3A271
C76BDD95C87CDB3B87BC26FC7A16D567EEC62E6FF0D471B4853DB8A94D4CACF8
843824F818083F10E88D52FC4253E8203292CB40F1414AE7E51DD7347007C342
CD70E8E9F2D2A13D71213B841DDEAAB208AD9EA644591C15DEB084165F9DF24B
B91D3BBEEC2E34E38EF16A0C3F00700A7BDCBBFED2EC0D09601AD6538288DB50
3478B051B5E16B604A0341FE621A58718D960D699D3FAD284310DCF54EB13175
19A75A539EE98E804AEA24689D3540F0F12951A3C01FACCE9A7BAF4D0DAFA946
FF65A4D2A4C39969607272C6886F44E90ABE27CA3A1F12A29D9B32E60E8E34F0
17C5FE43D0E69A99A922D98909B2BBCD145E59A5E7F5426B3988F73B09A525F6
8BD4915663C1301323180E760BE81CB874B020FDA3AE63340E4261E4F3E4949B
CC0966BDC4426190BE9F5D77F76A72AD925662E5FE1CEF9CCAB68F0BD33DA003
F11EB91AC4502FBD6AE48DA0F9D07C35B96B103E379B8A83A05FE728F1716194
1F650F75BEBADB2E3810388F3E2DC7B19F1BA9E32925F2FD9F19F4E8701F3E4E
4069125D7C401144740691E7A460021A47B1E27997FC1DDABEC5BD0EE0B20194
2D579C7D6727AA124083242BDA46D8E116E2751C5F298851A62B60AEBE82A929
9B9F2492BA35690D1EFD16215B8EF14E7A3803B93C28FA41D971B05B6AF3B593
E74AD1E68A5FCE12A86E63B78BFEA87D3949FD164F12277A4688BE96356791CB
8671C49365608F3EDECC109321AF92B4C29CAF073DA3A7D73E913D0D83FAC5EB
BD884D4C686056404DAAAD6F82F94F803FA1FB0DD8908D1DF08FB87A8BB83027
04DE0CBB1C6FEB6B517FBD7CF065120079E608CE41893C2BC96A347826CCDFD5
C69E161217F2127A59F1A6F22037641613F191F22D5B4CDCBCC2EE5615623404
ABA7BE6C5FE475481615B2AC1A2412E54688DD21E44CC9AF5F16E634AFCA389C
4D740B7B51BB141BFAD1080E7C726C1606A28ED492E6BDE9F800EFACD1513909
84E98CEB6A0B7A2A6F3E1D1DCC3B2552795E0932673E59ECC56DDD37A1D52BA6
C3F0E905978AB568941A163F4CE3AAB5C5B16F86016EC47BA6F3F7AAAA77C3B6
09C8C3ABDB6D514A76ECD37C37AA88B5860630B3406B494F7725975596F84777
D9CF48686EC9C5DBCC1D78513F591C7C10AB9D153B3D41426B7BF668B0D04503
56BCB686258462C1DC61095724B9F3312316262FD7C1AEC6E54DE7E5A7BD8EFF
035299B8FD8A4A7B0F51404F4A760F4D8B4C0FB7A32FA4B2383AB6E9C78FDEDB
FE6A5788D38A6701B123630C2A6D820A684166FBBC83DB17069494FBD411B333
CB37E2491C5BD035A33867A6D3A3D420CC31ACF43AA07182CAAE67E40EC63663
B678F71D4C6E0EC3A0AAF904CD3AA66E0DE5E3CDE049E94249B39A1C06E3CE9A
F974B2484BB2CDA14282B9511E505B3C89F9C802218AE40D1A7541335C5736DD
CD565D4B9F4CC78F3A393737EDB4FBD0DA299E21CCFEBA5478EEF013F0552A8B
0BB11FF46CCDB784E8BDCF730A16363E66572049E42C695886EAB42A9AD9094C
B635DF4B5B9BD9B9AE8455DFA3EEFC77653190F9A8B1E93B7281C2A21EA7DDA9
33484745BDF7E3DD63C7AC66C286C9A5A698A5E4D7A91710B7FF943FB23609B6
4B442F83CB795788FAB5E9CF3F75D5487DA26170E4561C7941C910B088C3B86D
F844B0F340CF82786A3FCF347048463EBD2006281A816627065DDA6CD4D3AC5E
2024BC96C7D896381BBB567951E7A1F29D4E95351298B000D29E5F3D0448CB5A
CFDAE1BADE9403B90371C3A07D208948AFA022A69C519434B6813086ADF518D5
88E0B92072A44BA1B3EBB630A13B7AB90992E85B6D67361C8D96F3E0D826FF37
17B67E4B1EB7BADFD98D7F4FD17BECE740ADF13C141EBF0A91CB105DABB32FE0
55086D56A0D358841D15FD349E6B95512E4EDF4C430216FF85C2ABE995E4B40A
A6044CC8820AD885C07E052B3F91C2E9A1D163BFFD210F7BE95B923E2500DB50
2075106DB541C267BD450B25B670CE80BCD068D4DBFF2D82634175B61FBD3BC3
406131F44C7D6F18D375D1F2270829DDF29DC14DBB58A30AC193245D18DE91F8
AB88AB548D8138605BB5A50073295534E314366E26665AE70482B890E4101D6B
60E4F3B37ABCA1346DAAE8FDB8DD9C832EFF3E73BA470E2BACE7B8515CB43388
C27AF99FF9322175CF8D4947E6B3846AFF5163E972156847F58A66660EC8A3A6
5FB47C9F637B4CBB4C73B6A080B0CF6FD1E9665E92032540570FFCC747C67C50
822811AADC404BC7ECD1673E8AA6C3A2F1D82F39430B58C29145E2F1B679C46E
94EDC711883F1E4EA84117A54757E8895A40401A26E1437B39A2F65CAADD6E02
D71FA8AF7453668DC613F326A3344F74AD7AC67569AF399385500ABDA5EDD3BA
343CC5EDD4B558467626850E752B9959FEF1454E53E7A3DCBC2255AD8F6AB4FE
894455118A61C58840CB68A925ACCAD75CEACE863D806916228F0614191A1CD5
DC9BAE256018615AA3725834519449B0A88B4F396654E74099C007930ADB1327
DD119BF799FE3B0B223E1EDA04FE2DA7A1C879143E1C33B6C6344F4BA033AD6F
8E88C33DEF1977796B454BAB2494C930F492A518E8198C708A75FFEF8C49C324
A718AB59B889DED521229E741FFE53F98EBE88B0405AD523254FD3FA4BBE96DA
DA1C27C1C979A0DD4E61C3B1F4C4DE01E42F1C4435EECFC02D97994BC8AF5270
E7CB1458D76ED0229C5FFB4A23B8716018F9050970895D51722CDE8F2EA3D947
DFF374D84915D5C5D16463A6FFCD079D1ED416C4347BF831FF0C4ADFB61295DC
4D5785BB0852BF472CFC97EC174491CAF961AB90629F055E75DAA6D9898E8653
5BCF379816CAE46FEA62E7BE8E9B953466E51828172C4DBD0E1BBAD1CE28B5B1
02B3E36403BE80B49A47446A6677FCED438F01D60EB10F478C89528FA337D0D8
88D3FC123C076507ACDAF783A9A6E24ED73BF24B6E0F11C13E532DE5F70B1491
307A6D9A2F2BA5099C8A07762E70BDAA74BA5E2BAB260C1352107EB8A96523D9
4BA3082B99772D585329AB8645C3BBD11D72BA01F95CCF11C6DEBFDAAF7F5C4D
795F99DAE6A8D59462D759001BBEBB59AB0C322EFE02904D82B424649C2FA593
0E23281DECC5AA908E54244566055D418602EEDBE78843300158908F77C0AC75
9562065826D34C38C598D8626BFED7CB672F132E065E2C27932F709935988376
94901EBAEAEC410E2B36575A71EBB8954C3A90EEC264E6115950FC91D0D54999
323D8B4FF8129A8EEC3900A00CCB026E6943BE1728BCD3F6C1BFD503D55A6A7A
6376AF4D646B2F31B1AF935446DCC68233C72AC164BB393DA250B0B423D32887
C680509C862B6F49EAEC995036CF797BC11DD87159241A7503B1FC87023766D2
E1CA46A71DA0AC46F5351FA1215F3B82978F3DC0082D300490B49742609EF2E6
D276DE76E9E50E17C3EAEAAFA02C1F5267A4D817513D5053BA3F42DDEB2DCCD7
C4B742DCE9B879CEE7404C6ED505C0176633E55256AE7F6441ED88FCC5AFE8F7
02393EC14872B0210839D0A8EACAD777E15251A27722F6A5D4E076F84B4D63B7
C903852146ABFA137726E859B4FCE41D74E10AB5C56DFCB2B85C9C67BD76DF2A
183EC8F23627D98C8A5D4D77077CA891B0BF3E41B525D0BB664400550DC7075E
69EAEC23ABA4DAD970AE8AF1DFC659763CAAD2DA1F75C879DBAFFD16B5591203
2A5D673C5DC457844369A57A61CEF199FD7073821916013F323F2BDE4E028984
67322EB65A2F8B132F91D2C6AD0E1BAE548BB71CCE2DEE7DCD8127A74901C40A
FBC533E07F88DAC351DCE1F4EC3B9242BD9C4178E8D45BF597C6298A84F1F708
A92A8DD40AC36F9374C3FDF9B6F291346E1CF577BDAFE8434FBB0606A80AF817
5B6DD59AEC8068AF99F3C5BA9B0C0D562B04EAFDCA8F149B6441A6D12E275779
3D3B1AA19F6972F2E3A7CF3CD677186FB3B2A389D19302AAB39099D99C8A80C7
22AEA8AC0410065384FBB50E1C6B8E4B363748F80C1C1DACC6DF1E8562F1465C
F71B2311994A1445EC6589C7C687DD762CCA0FD8F3CCE53C4E827481CCB61919
8ADC54299F6C42778D5558202043009BEC743EFA4C5BEAE3395975B134DC5B58
C51908F0637E3722368383BE62E6ECDE3EE4872B9FFF351318EBE893DD4E6E37
0B98B2F040CA146CDCB5908EF4FA3FD89279F57B466F63414F28DD6B045E901C
BD7C0FE5179E2B9CC62D3539050144BB4A4AAD76CC4AE9F49EDC6C88E9EBA2FD
88F7AE62A19FD9FDF2E06165E473991C6A7B840ABFB91358BC269BAC8C5CECF0
C1757F8858DB73633800BCCBA64244721A9935DD8982931ECD4B45D34C442860
062DA66C9F868EA73057AF97D527AB94DA14810FB5153FB8A09B94040AB467AC
7408BA76FBECB9C6ECB4304978FC947C97CF78851ED309EAF1D37FDD0B9167F4
1827C643ACE224B038E0A7742A58BE3895E92D56E4F814FFDFC5A5F1532C204B
EEED542B238C214A3E
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: CMR17
%!PS-AdobeFont-1.0: CMR17 003.002
%%Title: CMR17
%Version: 003.002
%%CreationDate: Mon Jul 13 16:17:00 2009
%%Creator: David M. Jones
%Copyright: Copyright (c) 1997, 2009 American Mathematical Society
%Copyright: (<http://www.ams.org>), with Reserved Font Name CMR17.
% This Font Software is licensed under the SIL Open Font License, Version 1.1.
% This license is in the accompanying file OFL.txt, and is also
% available with a FAQ at: http://scripts.sil.org/OFL.
%%EndComments
FontDirectory/CMR17 known{/CMR17 findfont dup/UniqueID known{dup
/UniqueID get 5000795 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /CMR17 def
/FontBBox {-33 -250 945 749 }readonly def
/UniqueID 5000795 def
/PaintType 0 def
/FontInfo 9 dict dup begin
/version (003.002) readonly def
/Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMR17.) readonly def
/FullName (CMR17) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 40 /parenleft put
dup 41 /parenright put
dup 45 /hyphen put
dup 49 /one put
dup 50 /two put
dup 61 /equal put
dup 69 /E put
dup 71 /G put
dup 97 /a put
dup 98 /b put
dup 99 /c put
dup 101 /e put
dup 102 /f put
dup 103 /g put
dup 104 /h put
dup 105 /i put
dup 108 /l put
dup 109 /m put
dup 110 /n put
dup 111 /o put
dup 112 /p put
dup 113 /q put
dup 114 /r put
dup 115 /s put
dup 116 /t put
dup 117 /u put
dup 119 /w put
dup 120 /x put
dup 121 /y put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE3DD325E55798292D7BD972BD75FA
0E079529AF9C82DF72F64195C9C210DCE34528F540DA1FFD7BEBB9B40787BA93
51BBFB7CFC5F9152D1E5BB0AD8D016C6CFA4EB41B3C51D091C2D5440E67CFD71
7C56816B03B901BF4A25A07175380E50A213F877C44778B3C5AADBCC86D6E551
E6AF364B0BFCAAD22D8D558C5C81A7D425A1629DD5182206742D1D082A12F078
0FD4F5F6D3129FCFFF1F4A912B0A7DEC8D33A57B5AE0328EF9D57ADDAC543273
C01924195A181D03F5054A93B71E5065F8D92FE23794D2DB9D6295729076BD8E
CBC0F4C1BE246922D2482233846A96D867B66D9CF25A1DB661141D36B8506E61
A022F9EF8BC1F2F674EDF1533E67A78CA29A612AA9268E113C5EB84DA56CEDFC
D7A111403E6E2A8682DB04368889747E003A124395ECF0C7FC81218552EE7C6F
60BCFB4120893528670D0E8A4117EA5676915E3591AE5652D003EEF67818A41A
8882E102AEEEBECBD15DCF632ED246A6A58B6A7780DB6F1F9AE3FDAC8344585D
E104F2BA2DF06D68945889A2A3B6C262FB53FC670BC5EB7C56887FBFB7AA7026
84115872CFB0652C6BB330447AFF8F0F665EFD6A41D6DB6877B08052F402448F
CB21C26BDC900636C99CA347B79AA73AFCDE9762A992CA3DDF7279E5C50F453F
52098529850AFB1F501A442D6A02E0A2896F81C8AC735AF1E7EE47208B4CC944
649DF6802EEE813F1456205C6126D7D0B1821AB62DD65468F3A30575E491623E
0054E2E680E4402E1C8C538DA389B81603BE88D6DC287A076F92B224CD58A0AC
44B8D490197341808DEF243660971F444A560C747BC6F52707ED42A99736ECCF
EBCB694A561C3A70A319D204CD40D402FBF937A00BBCBE85DD26C9E3F91B7D10
D85B9D314BC3AAD5A58B107F5F341BE2C53490924142566417D6BE03BB4977FA
6635EA58DEB9508E40B9FFAC75FF44C683680CF242FE210519C9BF92483B0A54
83F48341318BE16D2F8C988FE3DB2E7914581F579D5E323148A31E4ED03BC24B
C990372DF5F3B0C5FA32EB2CA4FA0EA33316569133C87697BAA2292E685C26CC
F8CD40A2366E60B47D47CC9D0FA29D2836011376A07F78BA7664DE96E775CF45
9BC91559A063073A4C2FAAD0893C517C5C46A1425D07EDCC2B57162E3A45103E
FF26A2D2F98B194256A4B052AAFCC08965A50EECD7B9E8F35AFDF7B6568B3983
8030655E7C2BEC961A2F20539D617626E8454E3FE9EBD3EFCEF7F63498441DAE
16CB509BF239FBBE25EFEF07A3E16C9C71EB8D9DCB8403916FB40FD7F4E1A52F
72F2DFF94FD14D7D49FE775390C17C37C1BA0CAF35CF75D682B7833A83224158
D54CE962CFBAFB1B2CA50B60CBEB1F8F58DDB2F5470C355ED9632342D9382AE4
5D33BCA3A0A25EE9E5B39BE5370E7F20684C664EDB48E7973FEDAD9676F9EE8F
701CD4D8CC9B9EBC06E8C86EB88AD56E15CEBB8E1930E8F711CB6E01D5D14967
D7E6C1BDDDE2C4D00384EF4CB02877DECC27AD53FC981338977BA0CC0257CF7D
B42E9BC91AF45D9722461EC3CD9DEAA8011FB855FE14B74BE0A102008EACA2B6
0E287BB4F466FBFDD6E65A5262B9322F95E20DAB875A10A84572D982E6FC7ACA
23C0C37E5EB47B8E69C07507B53CDD98CD1B6445E1699CF35B3DA3E0DC56BB76
F997C40E2ECE47DBDDB707EB527055960113F2DABC87FD9EC7D0AB36B400CE33
0D54D4F197B2830B43DF0AA802DFB2BF747A4C44B31FB708B2C8BBE1955A6A28
379C91AA4CC065A50098AEC0B837E180B76801865A43C74859DF18FE1DA1483B
C17843BF1C7E1B11A8C6D8BB8CDB1D552FE6A1FD0A696A8F7405F2320F8621EA
17C1A32056C45A9ED35D2BD12D02D8B26489CAAEBF4EF33B66FF4BD9B46E4823
6395831A8F3366EEA0D0EA88D612DEBF63DA7FAA24DA979ACC1A52544BCAA007
6C39946BEA6076ACF45722B2B8E4D0823EA2D12B14A98367BB0433A21FBD9F94
18DF298C56F67ABC9DB1868D431A854DBEDF8E1F49E359A545C75A7AA1FA4D5A
50F1EE6B45FC68ABF65FFF257964E4E50D8B0C1FAF498DFC554073697C2F219D
4A68DA9E873B270B9C56F0DDBC9927ADAF9203FD684DE615F68C24ACFFB44690
89C0D5322049FA69E7FD00EFC9C9B2BD177B5B339907F81C31496662847BEC1E
56B5DCDF4FE618970F4268F475B2EF7E0F28CC986DDF098E59DDAD818649CC35
4080C0867A884B8177A6880F06F1E5CC130AB4243EF8DD8032FCF390765BAB1C
1F0C9728EEE261A09F8C1D7ABC7A6B1550551BE2A7D19D45B656650DB00B3A5E
B3E1186043E173BB4DD5EFFB379654F88146382AE3F7196F099BDCD6D245FB6B
AA2FA9B6CFBC9F0CD52798DDF2F13874BDE5B124DFFE0DD93E24C9DAEAE4C3BB
71A9A13AE2860F620B4EC789F95221015D9C510CB4AC775EF69DB9E32E59C896
1AF82C9F0DCDB4812A37761859A3D3BA0CA57F244489C78065346FFA78F5F7C8
0B2E8CBA9EE62FF5C27369D0BCD52857D40F1FB8F8A1441B83565A4150AB1945
0B54D6E49F66389E43096269EF5CDD39526A288C0CB81E324E75D326EC9A182F
2CD966368CE300B41873B08E17C3E6BB51804460D2562AF5A12339966F44CD09
114C6809AF246B5BA6937631842CB9417781A58944B6BA4FCF961465C208957C
81A662D560D0F81BD3CB53C06B6D979F04F6121CCFD5D52702CBF6C70C01EDBF
2040AAB9CB144321E68C4010E0E98CCA2603EB55DD62E881DB621C37EA4108D1
528ECC7A0121B57C6BB1E26F8AE7161ABA7E88256D2D6A8B7CDE2E730D137493
3FF628EF6030DD2330D747FABBA03B44CF600418C245C388F33EC5559E7313BC
4B530C4FC12530D38B27D6408548F25FC084DD0523B27D29D6518D3115AE7755
37162CFD4CF528214466FE525B13782F9C3CD78F3D6C7423E63A134C0A371F15
10F4ECE1D482C647B563D3D15586F80BD9DF7381BD53927825D5AEAF762E1CDC
3BD184F345029A95B3AD4D1B66E79AB4F0809418C0CFD4D503457A190D02F134
3F57FC04FF655AEEB783D6791E4EC300755861837D3D50649F6B7F60766211B3
8148F8E575E28D6C2DE75B15E722ABFC6DAADAE53D89FD295352781DCC2CFF6D
982F6DB778D6FCBF1B7BDCB53F3A23AE6EB499BBFA96E8BE04C3C8E5B660EF24
01EB842DAEBE979F2C2DB72AAB4D21627063B1D3C6CD40944E4CB81655698FBA
A343766CB22E392E5DAE01DB33A00918D6DAA07F2F38B336A3C5DF3708865E75
0DE04D3AFBCA27A249E97377D5785B4E28EE0E93F7D353619C200DB967372ED2
153BF8BE945474266EB2FD30F80042A11B7E3586DE4AB1FBD4A741D36DE583E9
1CA25DA345520AA60634EC819E7EB493CDB128BBADEC3890F055455F060A1100
D5A41D7B180027E08AD6EE7E393DB9F83799544404FE397F557773BE6A130541
157C0EB37E036C94825B5090EF85F8B4E3DB72895D86687758C20EDEBD6D1079
196E9949DC6ED0113571C70B150B37E446E319EC54D44CC0CF6A14760953DF4A
D0E1F33A54D240E236AB63B35BA8E071D77776BE5B9312245F2C6E4FDB4312A0
0D9CF723E7D9A3D8546C4739C00C301A89ABA60A02757AB1A0AC40B24CE6CF12
5850485B11E16646D7150795EABAEB08364A53161111F46A7BC3423A0D3BEB69
BF15726C1F8363914945DEEB29CB8766328318AF3B344FD6D77BBB92BD7FD161
93356493D4D8252AD125708D47C124E44232FB2BF7DD75F87889496DCDB75D03
F58A57D4122CFC194B75A9E9C4789C9A33C0435FB4ADA16AD4A6191928D1663D
05FB8152C0AA176FBA4755205F8A66713404787070757D3721ED6E6D55A59DF0
C92BA8F05EC7BE05D0A2E66DE85E75373483EA3BBEE0F0DFC7E2FA5FBAFAB118
058D095AA71FDFC8AF37E5A98406B64E58BF476C6926725D7EF3C2346CE3F662
1E5A4A18D966479A37070859014719456EA2C7F23E68E1AB2F25ED3A0C00A18C
DD403506923BC983F89CCA125780DC76A411472E38173BC0DD4CDA7B43E13419
B5AB0B9A35E77C58BBA12AA4F5C7EBF8A29996B059E4FAE6809565570442AEE5
D56CBF4407E1CD9A4398B1F3ADFF023F64B230E3D29F526B62D964F5C8DF801F
E94295AD85BD9E1C18E6327977260A871E921C0745CA06A263E335E344686E7D
D6FE3ADB4EE0A7E462F3C00873C3E95D183CCEC71C0E5DC1D2FB310B28FC3611
67C23DE336C374F72368F4973052B48E39969305791C986E6EE35D0350571860
3A8ED849712CF21AEF444BA390644E8646CCA16559BA4642A5800827A0DDC453
7CA0818BC47DF6348A5209A2F0A10CA39840CE6346E89CA0E842BE8692DEF25C
4623A5A0E0B98708B9492E9F564324BB3872D6B953CA59E9F393C477E2AB85EC
C557D333E88C111CF995FB79D9432DC94C2BDB3BFEE13C0D7D1BB920DAFA6158
8548447AFC65CD5515D5021E0ED7D213B0C08C35BB424AA91885CA023D7AF767
B83E619B15DFEF5588D2F0564296E14B5A6ACE03751E1016105C51BE76EA5ADB
4167BAED2A8899031FD7BA05C410ADA25ADD94A787EED1A7AE133B0568B1DBA5
44B41BE013782CFCA3D81E8E8210DD506ADFCE7DC7E792EFEF438221164A7D1B
5E7089F476240C5F94988F081943F24DBF7CC3D1E58CB89E1C0C1624682CC3D8
C95815ECC9183A4B3E353C7F920B7E64086E01672DAA7C8A81319BAA03C1FBB7
8E5E84CC5BAE0E107754794C755B7AF00953504094E1A9DF357D51B578259613
8D26F0BA26AAC459BBEEB90BCC98B865EDD26AA4DF533D6624EDAC762C446B6F
CF9F86DD2D8989D4655775E662B93BF51805EE3CBA0AE2293D95F166E80973CC
82C53042D0249C598B0821E9E7F218BA6114EEC86C158F277934F2651490B723
7F0D0288560DA5BEBAFDDF243048E590871AD18B3B220EC56549004DF122AA03
BAAD6971D790BC644369FDBEE74A324083CFA9496C2A333774F06E35299242BC
F4B26578907CC5AD1893613F2B8622CFBB7B55810162EEBFAAEAB2A6D69CB72B
D7859C73843E665125FF450631F32E64F13A6207F368103C7A7318DBAF2560D0
F1CDD83C3E48CB30C62AF1E0896E1962C655D9ED98E1BB38477C1C60ECDB6B95
067D3A638AD43EE886338F7AD2D2A574CE6FD2E21F6FCB4220EFEC85ABF8272A
82081CE70E4390A74EC717F1DDD168F4A4A080A79EE2ECE0F98A96871DA4B52F
78441601AF47763C2219F5A167604C32F478D498835EF3A6167936994F7C7139
3019FF43C97E7978D3CDA641C1E391FEA572D308E759F28DDE2B40B5BC207A4B
C5EB6A93EEE26782016F8B6534420BE4D790A2E1A65B6CDBE9468152230384FD
14E9AE84418A44F94E6825DD7D77D0BB5486DE26A692B3DA96C81FA4440C5D44
8E7F3CAA9B8DF38F87E09C4D78841F629F78F4E7CC8580CC44E59E5D9AE8B2DE
C0682F793AE7AEC12A8AE688636197E8A08FEB70EFDB6203681A60223B9B0D39
2DA656E5E99B82130D4BE38D7AFE18568DD30B0CC3C73C1E2914ACE11A65334D
A9F18135E7B86157122CD221C33C62012FFB16D2D2F3473A53BE3E7B9FD4303F
66ADF0B07155C7B9B002EA68C6AC7247EB3CE7D2670A60138049DAA964F86A05
22983EDA7242E6BEEB90DF61C937399B2CE1061DF1E551CEED4A80D86C2D4649
C9FF9A1F93E96773CD392478D5B70D5336A03A274E0A6EF44BE8CB2274324142
706BC2E340DC944339D647961FD7BF29944503B4AFCDC69A706AA6B0F6AB2CB5
D220A96ACC1EE5E7826F6F75F044224E5260D581AE761AD0C752A06AA03FD935
FAD65C9EDD4E5505396E331D45DE88F0D1A4303D766ABE0702C17E2A7F53C0EA
96A4DEC5A6B6186F5DBAAB05DD78E38AFE630465BEF0EC66ABA9C1C9232214A9
795D105C33CF069F6BE20B179F4CC9F484AB63ED25C1212C457DF62CA0D56E20
608572216F2D4C09010B03A8AA6D287C8F514BEEDC1C912552CC2489858BF4D3
084882CE4F4B6FB9EE27C0168671E6DA154018ABEAD013C88E1D3EC918371251
63D95BA0FE20212C20AD3F4DB614EE36B488A3F55D94C1EDFCA8E68E54A1EED4
7DD168DCCF07C3DDB5E2B499DB5635C5C5056A7438120DB4839427D07F96AB8E
F842E285243E40259F6DF029E27779CCF3D3BD7206B2C341045A5A4AABACC2A5
91C6830FE05ACDCFDE99046F16F2AC183426ACA4A89FE5F09B7EB2F811BB5FB5
AF073BDA2886070B2327D582DCBA66B47E8948C3BE05E837BE4B81402A583403
74FF9E938F0E9DC3B1CB81B93DFD4070F9EBAED40BA570DE8F9A5C2C0A097311
22A6065139A6580E332473E9410D9F4C734794F79E41D0D437CEC7381919DF6F
A24B170E2BC97A6396A4E3AC3D844AD6E2B8FCE1C6AE97DFC5319F49130C3D6F
AF2541EB2384D5D4CCBEB976846EF8C2165DBF706112BDDDEC9A57D157F5996D
95229FD5C71B885D16B177BAB06B9DF5740A45C2A005778EE879193290419C0A
A4A339029E37E685B8A05B111DDF94AC19B1D85C8E6026E57E3D3B373C08557A
F96E6FE3916695ADFC1F0BF5D558565F42A71C61ACFEFC9026424397F0646642
7EDAA05794BCCD164A645860B57EAD53CB6899B18C6E9496EA4DAB0A0C272639
DEBC4FCBA94B3BF123F7771F602E7667C8F56E12429669F2219C7D8E294BE07B
71E88EA62F5616CAAB7C0198E6FF12A348E36B306FE2684A401399431B6A84CF
B46EE4BAA0F4099E65E9AF3B70274EDD6B6524F4FA38C23F9CD5273EEDC8C6C3
E7312B6E0497C05AD3F3C246638F01387CC11DBCBD287ACF54D8E24759F51415
35ED64132EF4158F54AB9F4D567482B3057880490F805822F71E7E2C52F7BC38
8B1F803AC3731064B90E5E97AA3351D17E73DC2FE526CD6C91158636E395867D
C1150FD3BD12493FFFB813AF0D08C8ED0B7418A2CF90BD5B783364358605D075
5DEA95A9299C0654EFB28E2FE8A41358A0DD124D0314A27558E42ED5F2D74BB7
056DE04D2CF13B9B804A3CBBA29BC155A3F18B8B48283194C33CE8291677E1EF
0721138F8E0409D49BB99F217607586D2DF00C29A25536E21924B4CF6702CF85
C02DFBFD2AA4DE3DBED1D2C02E21052A8D10F96629D0D18154923638FE0C48BD
E2DEAF11663E20717EA77A5453686AAA39D6FF7919AF09B1AD956FDBF734F49E
262F3076F62E77BD45122B55A5913902D9F91C4246FC235BA9C0FA4A96994291
830638949BED423387DA2D455A3C9122484EFF27F5367D1D3DD27D207D973815
965E1CFF36F43C653ED406F65348671D9FFAF55BA3FC266D438AF473181B7801
164EA3F04FEC870743195B3F467DE36B3719BAD9BF15A18637A314C887D46673
445BA3C212749B0A33136FEE9FE2C9A13D62E7ACC96378D257FBE0EB06AD4D4E
D41976AB92AC720DFD33B0677062C32E6F5C992A0324FD26E984B5341A58C190
D20EC3F1144697D514D9157340A6C9F82E62AD8CFDEE59F6FF86C6250CE33D6B
BB82DDB4F65BEFC6F6D0E4044F7BF307CC346E2FFD191846E3CA288C6F91CB71
5FDE855FEC5E38816CC635C470BF15263A10A409F0BC4877F7E6D4C223E3564E
E7BB5B320AAA5AAF4F32528F7413BFB97C70FF5E6843E1FE501472129BC9758D
7531BE576C75840CBC4CD3E6D9E5FF52559B68DE6E7827128BB2ED1BAD43F36E
A0CB68C1A147A7093EB02062AC5492DB7EEE08B1BDB187E15339A66269E459BC
67495937B4317AF66A498923322B087ECF47B601C26E253D223A784DB2D204FD
0668BD403A73723848018B7C86B627B9AE0BD9038F567CD5F670CAFC5C4D86FC
ECA211B713ACF8C1370191161CBB6C2592E8B9DBF3471133F2D9A60F15D72F9C
5E5539D59A6A7E124D9A38A6FF6EB7C71990716F88E1888295584F17D49144B2
B57183FE1C6ED5D71A48D20EA8C18DB6CA7D3C3A6403B9A767D805747C0D25BF
7F2F88CEE69141F72141640FD36EDB5886A78D3A1E0FA4DD0E213082C3E6822B
F981212D179C25CD0570748C3BBE642CCF1F43F5226B9C2EEA6B966628B185F7
11441471ED972022B4D84CF007C1D9B1D12804610E4F730DAF2F2D5AB767C320
C62543E261EDE128761D164A9843955BBFEC7213307B78378CD1914FD7D79D14
947572CB28073B7AA530ADC51270B03CEB7FD7ADB4D72671135435609A235501
EA55EDE2B2B915DCA5D50A7E3512B325253FEEE5FB8F99189924DE9EDDB672E5
653E83A354F6E55F47CB4B2F056C6232AA66CF460A06E592FB4DAB538C280A86
6C7FC5A1A8A411A597335E6BCB62888AC8539B30E8AC2A39A813FC4891B49E77
75375100F55E9F16BABDD3F76B2F587530D12214A376FCA98170E67BE8E450CF
CD9116344965344652128A18AA5FBC61A89117BB7D016B4F18A1BA8FD538B824
527AE4920AA6DE1383E82F153E65A5125C760B8504837A361CA77F3E807F79E6
B5402CE718C30F9F3B1FB8F7C936E6DF2A921A2D493329A245521FF9BAEDEFED
343CF08E4B93161A6AF8C5302AA1803522AE366D78F127CF4C6337E650B54223
4759FF49DFA25233EB9CEB960439B33FD4D747C3C54D4E942E48DCF056310F1A
3F0F0585372B2B33EDF03E51EA7EB54E60EA2A95DB2DA938087163965DEADEFE
F7D4946ADD5AB9CE33CF2B32A92F27B15E74AA617BAB11A3A5EDA08D878A6B61
EEAC4CCAB95B0BF364FCE334B11F799D28BBCFD028646679B2D05923A430DDE1
19196CF1AF5C0F394578717079C8ED5C0D23CC484E492FF58620B81C2E540DA8
16612FC1488A0617DE1D3F1DA7E378952AD9A3401BDFEE74E6152E9B15B95756
DE96322E0DAD3A7EAEDFE249D82CBBEDE059D026A52661CF5AF2180DD73EF650
7C06EB5B4B67B170F0746FDC7EF2F5743431D1209590EF9F0C943861FE433D3B
3B54777345E2CBFACF5B4BE02F221149ADFBCEEA37D7E594D68572D1A060D1F4
895CE8E7EE479A0041BFD859CE561A22CD640CE98BDFB36A8920B91A9114ED17
B1B8A348F62BF575A12EA98217B3DFF1A8C40683BCC0BEE016331692806EA007
753F6A2488850C2A9855CAEAD3B6028261310DF12F3D15E76DCF6077F1A6BDDB
02A29216E81C94D9928885FADDE59BBC499327064576245BADA6F8E510838E10
DE287F11AB98A056F8933057AB26645D57D19F9B3BCA77E5736B6D6B4AD46890
51D8AE6295C225558B45D9E0BDADABD4EE7C7403B21875303B3FC00E8BF3649D
673A5F7D5FA0BCDBC9DD45A8E1651581C4FACBA65646DBCC6FAB9EBF104EE648
E6E5E6457C93C535F49F3AF48F8630C702874A528DAAFDA234FDF8ADEB552BCC
A5AE54E669B824D165969F02D5B4A7A4C54BA0113F6CC884A80B3AB086162D6C
AE96EB166A92019667AB3F9D77CD8C31D6C323C6D2FBB4127F1F3C56AB4B9F00
7F6DE1076596AC6F2E88D5CC4C121ED60AD467902E57D7C4E06D7DC88AA85DFE
1E4FD0536194994625FFB626F6B8F8DB9799485EF1629C1633448CE0B962CD16
FE3915B97058E1D3573F0578E11253DD9D8C399CC86B30DD5246EC2DE9252D88
3309F69870D3CD241496A6A58F7C75D29158888E5AEC87B23DF0D9A0EDBB958C
58B15A0614E698E0489FE55468083D4616759462416C522FA5DCF9D0B40B62F1
6CA75D4D5D0A73EAB9F44F274097D43FA6BD528A5301CC56D91F750100AFB4AC
E2B951451CA574E0310C00258F4A04CDD8EDD5837EC4E04D9DCFE9B7D3FA677D
7CDB2F67270B40646FC3042D054A43265DF1C1525A58873356457400152CA430
F4F49A163D6D8C06AC58B7E00E8C7A986754DA333699EDFB8C1D6EAFC39D3866
B74B44A813D935980AFE6B2CCA6DD6FD26CF3DEC802B715D7E7FBF7CCCBF2795
994454124E3B02DA1305D1E61610ED5CB61AE04A2A5F06D654D257F398C2B50A
66E5B82C05B844A929B231C93686856DBAAB33FB9770905D11D3022E56C0E591
D1B5490587E85DEEB9468AE2390B2A5A9BC2313C281F74E06208FCE8D0708041
F60920A536D859FDE2DD43CD9B7E5BDB9CAC68E38EB1D6203DE5872588490C50
AD15ECA8A21BE2DB8C5766F53041BE51E106729A245E9BCF70A2B9175D490FD6
24EB82A05ABAD69234AEF80A69BCCFB2779BF9222FE08658E969C5E04E204E55
05819EA452E9DACC0E818A7F192EAD06DD223B16AC41E02F004A3C73E12D6C49
608B0C496C9AF601CA312BC74A996AEDAC3709DBA97AAAE956C340D417F78037
EC84E7B598E28950379172481E6BA202D5F9AE4DDFA7601E4CB70E0ED946D7CB
8C067888984CF6FDA23AC99BB18D2AC4954D94186E994702D17CAB0494479575
B03437134D05BE509D95EE48F9188BE76213EB92D9C170095AC4902D0C6BBD6A
A123005BD69926814CE954F437C369CCB4B706C054DBA59B7FF2DDBBC7BE19FD
F1BF037370F0C36BB21A3870661ED707C38B2D37CE6D88DAEA3787E49996CC16
314D616881AAC0404E5A00BB9B61906529D6C60C08D5DEC40495DF0FA89C7ADE
22BF08103E8B8BF5D6468115359B4AF95173C3D6ACF81F052C61F1FABF1EB867
D27567B590D5B283B519CC676F4C8E41199554B6BC60FA6D1CD614E0C7FBC733
562CD482E131616C4142668B88523C2015F8974F4F8D2C7E8DE8273221F3EE2F
9964FEEE9BF33B505E4BE8EFB67E9492C1C27700A11211EB9F4596E9B89079AC
2A77244980EF2B4C721FEE72D518458812A0300CE9A8119926FB1FE7B70A4623
B363386A16518D7DD5E1152317F0EFE561370A772CCD6C636F8382EF38276EF0
01BA57BA8A7BBF7FB218781BB896C27850BB2ED76CC46171CBE2BBD43C5BB987
6C617CA6DDD61EEE2A6422F6F3EF0A55D32A24E5EF2B21314DDA5953DCDC568F
B1F7F94B090C4093DA5D91B8F01C6C182B93D24F52A87A796EAB00E5F76DE5F2
FE89380352E81FA193020B9D9FCFE34ADB255181592AF388AF9A6E423E116207
9A2A75611F6155791ED3653B6144D2E59C424C262E609C9D914B76D7F97F4B33
F6F2C3B41774ABD230CF148457FA828C2176AFD2C48B663057915D247D08535A
036FC8E558809FD9357393AA325D1BEEC9B1B47E99FA20B66742BF39CE0CDA89
6555292F9B1ED69F323EFF808B979671C07CEC9692544B7A09AA6A63A9A8CC74
01DD8176D93F4837B42AC2EE25DE2101655DBC86102BA07C97EC101212D44046
C22EE9DA43D2FB7BC67E22EB061BB93759FAA5674D739E1C68F7B22206F4D2B6
3BB5FCBFBE3A256149EC87BB46FB17118FFED114F13B23475712BA3DFEEB3B59
D8D43C85D8EC3FB82533962452A29172AA4FADB7A56CE07D574341D3EB1D1152
5126285D83882C19670455E64B3287C915D99A13288349E108E0B573093FACDB
0F9F00BBCC7BCE0C217A2B6EE8F91642618758AD15A87B0D29B080EA681EEC52
7C1249266E3021A45B0C59446CA19C673CDDF2599030ACDA615E3F68344FFD40
FC2231307E3568616D48359435C8B2354BDFAE95BD29130554187DEBBBB911B9
B08782BC1FD0CB6444C03ED202209253DFDC04C7BD2DFE801698C31C5B090070
C89484A5099DCE40810506641B64304E911C13D79FD60405EA2443858C2BD888
78FDDC7ACFB97A30BD12E8911ADC0FD6BB9F93470E684B910F67D383AA175D66
5AD4F6D095EB091A26D6CA994E6F226899D316C3581157A1963DCEF828BEFDBC
E002794741AFA8523054B7BED53CD48B869978CD91F5C6F0B6E45D83CDC2EDB2
A541AE43932FCFBC2B67653BDCD1037EB6C47F460B083C26628EFF604D7C0C02
598FC77D745E225CEDBFEFD5E312D5BB7BA7894795300DA75112E2F017087CEF
24B389BAFC799732FC596CCD3BAC6B3A93A7946A28F948E31B89CEA072ABDFC5
9681EC1187143707E5FB67B9883DB32E4D19E79079741870D3CAE1BADBC48312
B2D1253AAF7DDC890D03FB1329FFB7E0B5D82429F44D215999C86BB6318ABA5D
AFD016C274413C1B927027CEE6CF57EB7F517C8E135B7D8E5FBFF4C3C9CC01CE
7B1FD493DC71793E84BB541EC42C6E644A045BE746E2EC88C1C8AC7D7CC1B21C
7A2850E7ABD6E573672561351894A8AA8FDA3047F019527D9ED15FCB83CE61A3
B41ABC74941451C8EF660AB145D2635F132D73F6ADE3977F9AA76BA022981022
235211423AEC223B5C20DAE1C9F60E279D2633F692E1B0C3FED41ADCE45BB6EB
6E785441B79CEA1C2F5E08DB1D5898A114D1D5F9AF95B81C851A5BAD306C704D
E64744699B2D692CFF8E31C3187B65A9D1198EF89740319031F1B8B4ED5CBE09
C2B385618B5A15B0F3BF1868C285DCF437C1605FA70E846A4AA7857C7AB38E7F
6CD73D56D8E027964C4D8393F4FC59EBA0BD736C7CF24BAAAFA2843AB4D8A511
C4B16EDC3CB04741E1C6AB1A45F48F6006D6D91430E9FAB2D0996C04908623B2
47677105EA26913799899E809F175E7E2CAC3B1754C68400226DC4DCB2F9F863
1FE65648109D69C80C7290BAA8B8DD1ADC88AD8EF327B6D963C09ECA0EBC634D
FCDBC6BD307F0282E761BB0E50CE2C0429C781DA744FCC51D8610109552A78A7
EBB1A4E84D1BAF21845FE99C79615B15F35C2073ECAF354C08BB676042D38CD2
A41825CAC42E482EAB3888F59007DC7CD7EDAF1AD37575257DD30C8EC5AE3DFC
299DF8D9F8590B387E7C9B425170C564B1718CB2C1B9A2EC30539BAFD258F424
677AD17BBC18FBB095014D1D0AD92D5EC257B07CFA3EBAB81F8FCB42A086C223
BD96E4D96724B958C0EDD522C4ACFEC95237D9C67DD757DB9C1EB050710D8D51
DB0D7BB73528618F8D292F1F5746D7BF0ED489EE247DDC393EB3653BC0B8C89F
ADFBBBEC9FF391D3AFC553BB3A70D8FA851F077296AD974147F4EFACE268706F
805CBAAB87DCEE69A53D4DA17A06F44E6C6D4D1267004F60ACA31CB9D4931D81
DC972C04D8855675CD9D79C8AB4D4FE6890EEB68205CDD28DAE3A67502BC1D78
296D16E2EE3D3730CBC00D92D5D6C44A552828DD4484A69987824EF84311CAD0
D6B3C66DE957BD052ECD359CD3C4FFA25EE36F770E56FFC7D12D9E7A6FC57B31
B8A388BF46CBC90D2C020061BEE5402E22BA9DD9BAC189CF8DFAC504BCC396EA
51DCA151DA6345CECDDEC939603A610B985EDBC990F8A7B57E5FEDB748922BEE
3B9E110ED55F9D39423A7EF6556667ABD7C0D9386C41E2E41AE3EE33B62D3D1B
F8537CFC43C8C00BE3F2B7D502FB1FBA2BA3080ACC3D1A62A1E4158C28B42054
01CE106557DB6C97DBD348D6FDEFCF41195A619CB01B38B2F41A2E4D99F7C675
3621DB7EC5BC1361FDD6CD17927876103DA4C57D3A9EAC9DBC4B655FCCFF17F3
BEED876EA7958C9EF0CB7C8938F22C17D7A81E041151C8DF987CF2A5C9E83EFA
0DDF32A5B525694AFD1C32D66EBCE2C7873AD4000399ABD969A405D6ADE878C8
5CC2DAAC1D23CE45EED818AB986521CF721B282FC769FEC570B89869E174F7CD
43E24F16D85711959695D400D3032B9CEDB661C9D98E2865AF1A6142181A1883
754FA70997B6ACFC60BC48893EBD6F88D88B26B6194055776B41B54A81808A17
9069D4C07D048221A27600FFF981FAF6A329D61BE3235A4589D09042B67A37F0
CE349F5F8E24796F819BEFB7C1D3E64C3B96428B2BEA7261200BDB6D426FA629
54477ADFFB7A90B106BEE8B178FA974394D0B6A563D1561FA476C14906AB492C
D857E141204F190CB3017E30144BFE34100EAE029C5D230965B2A00890DE956C
E915190C609CD87D68B4DDC36FFCBEA9E54D45B80D68D4E0BB500DE82DB66046
5D3A01CA372730FE1D04ADEEB0A2739853755A7BD7158896EFC70330DB727878
90187D87229340827B49ABA7C0C06CB2F0AED74081F6CF02EAAB4A3D346C0294
AE15C9F59F18974A78AEF9A7BC5E507919284AA23ADA95DE33A79B2B1AB19BC9
882E1BD82C260611E0E530647569B3D0241E39A771747FE479C975F9D36B9392
9F3BA7903F71146616E29378BE2C6C6A303511384FF208F088D3A549A71545A0
205D104AA6608DC5C7B44059C434F78ED6F36FEE587CFEFAB6807C675BF97AC7
7D0B2BB4CB8ABE4E338FC59F91528B7B2DB48EB5C7A5483BBA74C9D2989EEDEF
C6EF504ED03478FD22969C086A74AECB65EE3F48E022656AC66641C04E118BC1
60EBAF8D8B26898B75005CF64121AD333A54D73A1336C16BE6DAF62991771C16
2BFB9C0937BB9E17A308EAD66DC7D809DACD06E7A40ABAB9649CDBB2FD9B81DB
C0AF5AA2BB98470C94D3C7AFB2AA8A72683C54B45F816D3D548D0098DC01236B
C4D71F8EAD1EBB7B276E1BDA7248147D1C4FACDF97D0BD55FD5EBE1CE41A0496
2CBED6DE1C8154D9121E3ACBC0BA8472C723E087A1BAED77C52A1FEBA4B15411
CE0F63C387433A5105444BF616B7D2B86749E06788F40922069DB1E86263A447
05E06044F48A0279A2534125DB0E0085FCCDA1906F124A8F0AB3A42534D3A763
3F09DAF9425043DB2C9851E2730C491B9A7B1EB613B1D889E5519701E8E98106
DAFDA9678E5EA52196C0B51666B43EA6E132DDB4A86986883FA7CD1A64809CC7
7F796A87A69DC50A239F82A2AD9BDF1EFB519AD7DBC5D7F67B8580B4DC439AA3
55AFB5749DD10E6168CB8E7D79E762AD620667B2535B2E7BC5DB83EFA873406D
803950ED4ABDEA6F46898834648AA57511F21CBC5458DE0122906E7424CC62AA
9EE6029368EFE83638290BA696A326163D92A918B3BB84E7C0E48A8FE56FF5D2
4FE07D7A68AF68935F17CD6B8462FC370564309C0F64E31D11EA85C269B33AE1
4CCA3CC769989BD5B0B75CDC77B570FC395E568472007B0568ECEEF136C840EC
466821EAE178FDDF12BD492A16EF78F20C0DED408E53494F13FAC9F0876374D8
ED4E160FC40EDDBCE0BAFB7BBA01E9EB9DFB232BD04356911B4186A80D780A59
B3F87BB9473D4178BE019992AE0BD290E9C0A0450ECAA0F3F0DC0B24D7B6E456
736BD520BE3F315B14289D18ABC2BF70EA7E4041E501228584F0035E5C41D87C
59532DB77D26E534FF80D6C78FE6511BF767D2B6DC39B9EAB91FBDA5B7E580FC
F566A2A464A00C817F7BA6A461B27E825C9397B6B18781B9447AA935166F7074
D119E950F58A6092CBBFB1849CC63AD3AA3BD57630A1B4A41B80A7628EAC5359
2EF711ED6328F5A19491928BE48568C76E60E09B5609DF7128763167B2CB7DA2
0C3494B52E32EE9B72F403E16C54463ADAAFB0F7F6D5FC9143E95F2D015B19CD
6BBD5EF7ED35985CCF43A88F4B8938C2EA915F77615490959889FAE05B91EBCB
4C4150AB32A5AB6EBA143819D03F6E876D732D2FB05ECEAB0921133CFEB16052
6F2A247DF866FA18B6AAF853AEE20642F95EB0A346C45963315BD7EFB12250E8
132438DFDC58B1CFC4734FD7BCC8D3C4208292BDE83C64380EBA711905D8C8E8
7A7A2A66C7BC49FEA68BB2093A17A1D7F23930D7D138069A80B976AEE7136B0A
9535635B740E8523356A93DE13A4E17FE01B19E595320AF80CC66EC532D80C1B
20B176E40F6A6DDBB556F2C76F4ABDEEFE406B5E66F70C85CD8FF5E5E91DC547
DDA13ED7145FB54BAAC67E95CAD7C50B7185D42A0D6B580F9B17BA394458C420
94347AF7828725A5FC0B5C38FB5BD11139E63887F2E998
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: CMMI12
%!PS-AdobeFont-1.0: CMMI12 003.002
%%Title: CMMI12
%Version: 003.002
%%CreationDate: Mon Jul 13 16:17:00 2009
%%Creator: David M. Jones
%Copyright: Copyright (c) 1997, 2009 American Mathematical Society
%Copyright: (<http://www.ams.org>), with Reserved Font Name CMMI12.
% This Font Software is licensed under the SIL Open Font License, Version 1.1.
% This license is in the accompanying file OFL.txt, and is also
% available with a FAQ at: http://scripts.sil.org/OFL.
%%EndComments
FontDirectory/CMMI12 known{/CMMI12 findfont dup/UniqueID known{dup
/UniqueID get 5087386 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /CMMI12 def
/FontBBox {-31 -250 1026 750 }readonly def
/UniqueID 5087386 def
/PaintType 0 def
/FontInfo 10 dict dup begin
/version (003.002) readonly def
/Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMMI12.) readonly def
/FullName (CMMI12) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle -14.04 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
/ascent 750 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 13 /gamma put
dup 14 /delta put
dup 59 /comma put
dup 62 /greater put
dup 67 /C put
dup 68 /D put
dup 71 /G put
dup 75 /K put
dup 78 /N put
dup 80 /P put
dup 107 /k put
dup 110 /n put
dup 118 /v put
dup 120 /x put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE3C05EF98F858322DCEA45E0874C5
45D25FE192539D9CDA4BAA46D9C431465E6ABF4E4271F89EDED7F37BE4B31FB4
7934F62D1F46E8671F6290D6FFF601D4937BF71C22D60FB800A15796421E3AA7
72C500501D8B10C0093F6467C553250F7C27B2C3D893772614A846374A85BC4E
BEC0B0A89C4C161C3956ECE25274B962C854E535F418279FE26D8F83E38C5C89
974E9A224B3CBEF90A9277AF10E0C7CAC8DC11C41DC18B814A7682E5F0248674
11453BC81C443407AF41AF8A831A85A700CFC65E2181BCBFBFE3573BF464E2BE
882A715BE109B49A15C32F62CF5C10257E5EA12C24F72137EB63297C28625AC3
2274038691582D6D75FE8F895A0813982793297E49CC9B54053BA2ABD429156A
7FFCD7B19DAA44E2107720921B74185AE507AC33141819511A6AC20BC20FB541
0B5AAEC5743673E9E39C1976D5E6EB4E4D8E2B31BEA302E5AF1B2FBCEC6D9E69
987970648B9276232093695D55A806D87648B1749CB537E78BB08AA83A5001F7
609CD1D17FFA1043EB3807AF0B596AF38C91A9675E2A53196FEF45849C95F7DC
182A5EC0EC4435A8A4B6E1CDBF9A5AF457564EA72BF85228EB6FD244F2511F5A
CA9B71A65D53CC06EF5F7EC3A85106139A4D312378BC22183C09A229577B793A
1B7422611C03E84BF809F46C62CE52D3AE29CE01C32B202ACDAA5B72733EB0AE
C31D7EF7BA88D2D14F85313F7A8B9B7A5B124B03AB923744D336C969E5CE304D
3AD977A46664479EDEFB69F113024E761C05FA48A54072DF9E12C2F352ACB3E6
D04F6EEFFDE209E7FA3DA22E5B1D1409461F4286B7F4F8251B44E5CB7805762E
E129FF4A06A7458F3191926B1CAF70E32C6571AD2DC07C34FF62840896F4D200
761B1A7FA356526D1E3AB4C542AF13623BAEB9F61B1BEEF79A9205B1FEFDAE24
8799D516A9ACC30BC0139C63C9A0523E9D5439213B67D490C96F902958779B8F
68BD8E9FDDCE8A3A2E35877DB6C94B7612382ED8F218EB1157D2ADD090A2448D
10B99FBC9211C5629ED1C61C74FE93041E5AA03EA4AC3FFDA00C2B6E719CFAA4
262FE17F66804A6B54D3669836EE4367D2A2991580C5564463C973CA0DA38AC6
922716E13B4A807B50304B8826CEFEAA47C305FC07EB2AF25FA7945797237B16
56CDE17AB0834F5C97E0CC5741B061C6FF3A8DD1A79B9A173B66A6A750538E26
32FBC92E75BA15CFFE22A7302F47908547007402569158F62C29BA2956534FEA
7DACF1E507AC309DAE8C325F2A6023D2FBD81EF42146BFCE6A16A6310A650460
7B07BB7647C8760FADDF0DBBCD3DA6CC4645D1732DB3A22D8B76E1D2D48E4D4A
46F4BEB80CE65F3517283A1AE08391FD1C10ED452133706BC6725AABC80107FD
754A8BA47B0281D479F052CE26A723EFFACB79B213041A536542AB334769A2BF
88505D82C498ABDD5A73EB539530F47CAC52825D16A969C8BB56D4A7F2830B8F
CB63B92B576E7BD922A4B25E634751F8A3B7C4EBAFCB373EDC8B8281B1D1371A
7844E9AD990CFF09F0D7ED73A5CF873D2D5C9E8A9923CFA31E1A4B4CCCC40760
8B3AC8FC3C88BC08BD7407725281BB879A1A822D94997826418F1B89D303F2C0
BE7A0102E6F529630CBF1BC5BF3E4578C164A3DDE45E62A957EF3FB7F0FBBA6B
CA1E79A1ED195B6A11CFB345B663C5E72FA55D80476F604F6C4257B51686AE25
8F7D159FE605DDA0AC74BAA5034F29FFFD403070013C6E2D8EF6A0990D91173B
D5A3AEB98B64E412991505C3CB7C2CDE13C091FEB3DFBCAF30C4C19511102300
135BD5D444BB55692013F52056908DFAB2ABFACE81A58423ACEC59344CEF7D4A
C5A3EFFFFF70759BC3E593D878281225060B97D1BEE6B26EED90571FEAFA1812
1115C0EEC892F5DE6FDD68321A0B3F10A2D771B79BD85476AF6018472A499A86
07D64CFF4550866AFE590C471C80EB12CB3A989A60BC7BED39097C12D9286E39
14C7952C4C64820B4DE44A1827B7B0B535244E93FDB80036D6332F90F95B472D
7031E7E3819E881BD0313CFA112EB3AAE943C99C47635CCA7E34DC0306C04E5D
2E9F60FF037EB11602BE74E8E6B711392E866E3E55D988F7C856417A2B9C186D
639819B4786D039B77F8578EF63C088FF28BD08D8353031445C8498A8F445BC3
D08923D32AC04BF3CAFEFCCC1E77EA894F4E846F47EF62D6841B8D8576FEAE8F
90044626869D04D61D64D56E8C51AF8C18D6CC3FEF3B6C4F7D56FE3260354948
10104F69B117FB8269292579A7D52FED688C663B643D8D99F13956612271073E
1A337AED059B7A93819A28CDF01569CBEB51069D22ADAE25C47355560F402B2E
8C9900DA82B79C64497C8494F42FABE5AC41791C2010D98FB7E593C744F250DC
D837DB0EAA4F75D0016970F3AE8359878A08CF9A697A06C5EA945819151265B9
1A12122B98F79185DF852257BB4798E7DC03712EA6ED34F6E6AE1476788DBC33
9229FADB8D581BE1A63F596698DBD6DB98A092F67197A4FD4A50B648F2691875
EE2495D6BB310078F516785A0CEC7EB6E8305FDBAEB1D15690409FE32DD9CFAE
DBD3866FB63EBCAAB73E3E4BE5D7F3AA44793938AAF3F8341683F0790F1D46A3
60CE083F9BEDDA22E0639A92393960F86602216FA51E2754BC2F4CD0BDECE3D8
FFAB7E0E49613DD4956C9A10AEA798BDA1F756C755BEC12147ADECAB0FB73B7D
203A11D84DD2AB5AA98FD38C1C2573570FD49A4924A94A106D2A7D850E793608
FB135853E8C4204441CDBE697FD0CB330B1C3596F32D2BCBF263237EAB362D09
DA6F531B40384DC91F30674760CA7B64BA1968F6A7FC9EBEF431A1AFC5E76D7F
2D44DCB7F61C7F6B16196B3E8B47343F572DBA8B8B21B43E35BB6B2DD5C7982D
244FD4304D254D6CCB5E8CF70E77F50812F41A988EEB3B26BF0F6F69BBA18077
31134B5A5823D10FEF6201D045AEE7A24E0F25376E9FC66340C56C05F6CD810B
724D85CC4BB8D789834A447CBBA159565D08BA5793D8599035BB5063271518E8
F6C50E7DCE71B1D186270DDC860C6DC0CD506010EB5B1FDF6BE47A9A18CC15D7
D657E58BED9EECAD5CE5D49F63139A39BC52C6584BB2C3264D51BD584B40F8EA
AFCD8B83F548594386EB2B05CE803105E84931DC6E7A1398073D48E130E0D907
CD0F1ECC3254EDF5D4DDBF44415DC9BA66C673820CDB0FDF033D59BE2B5EFCEF
01FF9D33EDC88F8D522E07F1689D024DBCD09A16A63519E1764C8630FF36058D
CFC07027E0ECDA01E0E85B166C613B22F587B4D355EB018BA93E92A36007B4DA
287FF5A91F7D8A0EDF5554ACCF45AC8066E88865C5692E63EB99CAC81367B605
8E6C19EB98EBFE0D2D161B447B9A70CDD1122C7B78A413369016E6D8481E2AE9
9AA97B5DD0ACC9B0820F7742CEB2F46F89F3E2092621969A88DC0156B4F941A1
6BF1546D4B136657C47B082A8A35FE96016BAF3D9679B8C32EDDD6AE6DF3BFB5
7854074FA019707FC22BFA82299E72ADF9A980AE29A8E2434277E58B01F6B03C
192E1E25DADD49F6E3F69799AE62B56E00B60A031BF8721DB8B2CB6D4A4C15CA
AB1FDE010AB7DC0DDED977389B101B8E53A949222FAA126656E02817DD32B0D4
A49516CEC2B97EA7C78FD66229B044EB92F502384BCC6CCDFFF995EABE3BB7A9
50D5D1AED861E7D3BA8D333026C673C5762712E763E59261426044583D789C67
A606B96F97663F92BF104CE02FBFDFC521EC0D6670B7D4F85A229F51426DE912
3B729C4A535FB7C88D0A5E78074751B58885DD6BDD2DD9E9C83F105E8CF63DDF
CA7DB39D0319CA7CC2E73F42747F007574DE25AE1538B4D493D22D0D5F0F80C6
5F6FA3937C8391DE2F0116F81DB2DB0EF751EC838A7F85F163A6F48804E84B96
8D715EF25B7E2A5CAECC558D80F421052A1D698F3B8452AC27E30A4E6226E3CE
084C8A83ADA0818A110923CF7AC7AD4CB92AE4ABBE0A9EC1FF935FD02774C1F7
92A278E513012AD17722A23C55EF82E18F8847B5CCE47F4FE3EC508BA563F7B2
AE56C94285A18DED4D432FB0CEFC05A20BC17DDF9FF919C724810A8ED7358A27
97EC93C1A13C443A91947FE1F6F528EA7B628917FA7E554A1D7B31ED46C5ABCF
92BA57961C8876DB4041305EBB029B03D8351D5E2819FF87E97ED214D8F1CEF5
7F7668DDE223721C0B810F4A4AC81CA4EAC86EAE546E1B15D91E626FB9A31824
5BFF17C4E79FD56ADBF6DBF01BAF6453A81EBDCB38A5FC0FD0FF0646B3B0D199
13E2E59A1B5CAB6DE5329BE389BA0E2A2AB55CA40B711ED746C24F1E48892E76
6DACF7DA163CDC90CF076763008E7A899870CDED5A80758E6177BE6B93B07EB1
5800A3BF7B9AAC3FA825CE594EF5B7546B181375FA8F37608DF17856D2F8EBD5
6030A9E6F6BEAF224AD2AEF76D03B023E2FCB922CB8E3C6816AABB61FE6E4F83
F21B4935102C860ECA03DBEFCA461F0E5B93E5A8D18440BCF7D1D6252A24CB6E
A64FDAC8B67C4888519AA368D9C4A8C08C7155DF5BACD75C5196C571C3C456C4
7CE8D90215FA6EE8CDD72C48740F7F5930EC3632DB63A9C8D2DA125088C0F05A
9FC83D16B7F53163F4EB6FF372C6C3115F1E68EB35967D11126EDEDF0BF80817
E68A698183B3EB0A207DB43786E1B9D289359D75AD5E465328CAA90E712C2962
AE2A466173F2FF30EB535A6054BB0B875DC8552C16B49DF17CF84D98D35497BD
F55E273FCBB0C735899529A69990E09149FBD2DDE64B7FA8D50AE83925DF03C8
0B63EA158FBABB12A028803DA4B9DD6C48C0FEC469C4E730729F4BB420D5B003
1918B4AE9CF35CFD31E8E62A44C0484E3D00143BF1D330235E821E5CFEAB4D31
7CB4604DB1F310457FCF9075A3527279644D908DE847CCD00B6F50DBDEF91D3E
38238CAF550FDCABA2C3A46237218DCC5A09AFAF69997E1EBDA7EFE6FC99ECC8
5D4AFD5EE35FE2346BE79B499EC8EC436868154A947D13BC02C780EBA4B9E64F
3026F1BF5DC1F8D64FEA1281EA40B4BC355638A3A59BD9055BCBB232FA45EA0B
B405131B64F105814019BC55466EE78E9E9ABB62DB30EA452F7EFD7196C76A85
15B2CFCD89922CADC0F392B0C54A231F3999AEFB53C24EB0C63B0C8A1A1ABB6B
AAB2F93E5ECC7AB90EADA320E918106BAAFC1F8C425C617639984629018BA674
6FF4F338AC43E23BC3740542911C058D43A49A11CB3A0CC8E3088BB5BA6048D6
CC2AD250DE956BFBE83BB24C945C20D9C22E7105983F284EF478F9B68BFB0322
EEB7D62802CBAAEFF1C2332159DCC7243EA40CE15C734EA905E04C476B178B82
A08ABCB0B86A7330C75E62EE7844C9E22DDB013ADDF20AFE08122EE1B930A81D
806A0F8CC584CB7FF5F56F9B35E5FF78FD93E7E4A40C64537464EAA275FE88F4
461FC6A467C8A69B9A9FBC10D44AC1B753D313A8E7D97F5FAEB60F82855658D1
4DCEE043C8FCDFD8A29DD091F3BA55874A458B2B8989F35055C72FC411382361
9AADC717E602B48D7C9521D3971A6F7EB19D539445DDE9EFBC5B58FA9E5E426C
172C45CDA24985FC4632287FC3B15849DEB56F5A061993AB10A6BC59868534E6
69888175053108B77E4978D971B4EC57224C0F93EEA4C15AE92254140A94704E
ED5666FC06C5341F643F779CC88A9E81891565C63B6F7F6286E664F4E0A48690
356DC96F1B98026C563700772485B83BFA06435D4E0793EF822F423C93FBACA0
E5D889D2B76771C6F0EE997A5DB43C2F6921132890406E3C33F6F159B14C5D78
7C151BDFFDD02B697315F191B5490073EB418A4FF2A398C68D44F0CD1B87CF9C
B52F12728B72F94D752D23151196A256908135C87991E508B8906CE2539DCA8A
31F86809C8C6C18A09F6129BD7CDC6B37E76B648788056851F22BD3E3B5772FF
EC01D822B57FFDB3BAE624F05531292641FD6A7E3666152D18F6C653048DD7D7
98A942C840C4A0FA662F260B21C64214152BB86F03662A330109C5AC0A5EBA30
C6201F558858130703DF76AF4FBBEE069BDE45C0D9467077D85FFED4F9BA9C61
AED87D67CDCA453A6528AC5BA153E1039D9CCC556CEA5CBB542265FF54A1B208
E0E13740E7E7C26AA00AEE909F8F3ADC2726081A744D8EF6BB711BF5F611A900
76F91C26A338DA13A7160A9F42410CCEB3190000D963D036FDA05A29F598EF40
8FAE6F8E7E6F50C99C3304A573501C13A00023085F057DF331E3354CBE65D573
CAE73BF15B3B96B502E0AAF2B4A86237E98A997AAEFFF4227D5A26E8972C48E7
761F430733E6EF8AB2D903C17FAFBFA21C25F8A0AC157D397BF3CC1AE7598F0A
2BE4FB46B29443CE57F41FD5F91122E9D86F903E94D5B55E2BB95949C156D138
89883BEFD634311F9280C7F028DCA6408D3A682DF5B55B9F7ABF08F019190F60
D39E4F0E80F0594235B09A5320109638B938633A2C196E4ED2B43DCD8643C3CF
C6123B076B7F73352F906D96FDE0FBF50CCCA432712C574D5857838BAC30B485
D25024EB254A7EFE57D1DF0892C275CDB3DF77602F0FED0FAEBC644BCACA04B8
B424DB125E487794CAB36E01B5E1A26F5E1E97A739AA36D77A12F5B45338EB39
AF36CEBDED55DCBFCF497FD475FC6BAB5530AD6153C6BD982564EE8712185F1F
D5EA7ADF4104661168A01994C1FD773A50C8AD6A3E4D332E4D59521BB8BBC6C3
866EB4AC3EA4532477E6CBF6BBF0860031C3B916AA25E3492670EA67F55CF4FD
207C684A0DDB6F4AD21B2909CBA71BCE2E762012B0927BA72367A6AE0AF87F73
756C9BC85E4EDE35317E2CCCD138C02C7A8013AFDC1A48C3A4BB8EF257BDEEA7
60E012F54D12D31D18DC59D5E526F12567B8688B4B67E16B56713870300016BD
A3B9DA87FDC865246AF8E94316799110D86B1DDADB8A673402D4226C519C058A
1D1E5A5778584FC28AF12819B1924060BC4F54B1054EA6AB0149E04B8C4302D4
A56D8A347EB5D3D2A0E12CF7E35059BDB53D9FF6BD25F6D9619BC4669CFC1048
C6C9978B8751B840F27D82A69075832BE59F55C1737CBB1220FB8FF691FDBDF3
03BD7D225A9372AC221C38245E48320E1CCF898D9EEDD678E5B8C65B7F588321
1A3953EEB9B39EA9A8CB72DB08C3E9234DFFF5FDF9DF804C021D57E97DA7622B
97F4CB6E0EB640E0DC9EA15C5193F92A3A7565F4C7A4C9CC327F7CD2C44900AE
D9E76FFE62FC37FA376E77131B566AE67C3E09DA80F198BBB995EE8FA47EEDB8
4B467C6C7DB8AEA745CF8C56B8BE56534E9C56FCB2B7006426DFE93D728FA4CF
94F131C549814E54ECE7C914C5FE8E4961D3437CE7475D03534B62650F551D97
201C794AA877445DBEB11C85ADF6119B05360700F8CEDE4766E3A1D7A35CDDC7
9ABF7C619E3868A39D1852DBE1EEAF5D7898C78323873AC005542B68C43C5000
CC58F675EB595F87C879694751494676465891E8A897158B481F11A171CCBBD7
29603F00210CFD7FF31FE3D273933ECC34AFBCC4108D9B76D9ECE63EA06CF939
4799092A54A749DACB82C1424E9879672C8BC084C360014C9C1B6D5D65C68AED
66CE329C3AD712C0A36BE7EF03FDF339CAA2E0336D387A693B1DFAB5D5164E31
14755A158168962C9B399F8F1DF3FF5060D7464D5071058C30C572A2BC7DEE53
84BD7614A4BEC4C84E18CF7EC81C811724463BD46CECA5FB57B0F55EAE20CC74
6AD815D1897B037C197D2456797B992C20C70B663BF99FE28C513B4E221C8E12
49779F8C0AE8517048ADDF7CDF0D698E3EFE60071C4997B7F5EF12B6CB65390C
224F13FBB99FFC034C0710F05019899689B6D3350BBA65C7CE7C2AB03D81B9A5
5F3D65E4D462DAB189006669F7390A78A1B8908A4C913B15DB8827DFF15BB9A4
A6037DDB643103B937257A7DAB025F09D53FBBC2BCB6B0BCD8D56B2B2784E498
1F6CF8470DCC892AD0CFE11578718948BABF9C14270D5EA00ADEC7876995F57B
B3750A12D90AA175AFCAB68E2950F3A08A52630213BA27DCEE62045A81539DFD
46D96EA8107593EDBBEFF3B1C072E4F97F45B76A2287D05C655AAA27351212FC
B66B4CE984E087D789E2C081F4DE7D2AD9CA50537F9643D44B6981772E8546A6
D79EFC003892AAE820DF8321C365A5104F9DDD15DF126AA7B5227BEBD759D429
9F4BE13666736CA653CE57E87281CFFD52BA729213B809F93F262B4D50A92969
F863CC4E2CC4BB97B92FE7115CA9D7185F637ADC98CFB6061E172B686E9B773A
4F8E7745B78B6C62D9664B0FBEBA67BFEC5F661D609B19779428F186EC532EAF
53C76C564CA1B1B360921675AE08C64E4C02DC656651E89AE366CA879D1C1218
92352D96AD4FBF7A1FB02255823CF3C6EE1C81A72B96FBE1AAB1ECCDFB750905
973944D1622166B45A4B5700CAC94EB5079399798BF7A6A10749DD2BC56F49E0
529236B328AA105ABEEA9308BD9D6F41F9EE67AFC9B00453844050DE75FE9DBE
77090A91CF67587DCD4DE633CCD51BC31DF20BFF3F8C099574FB777E26238F80
2F88EC531E076EEDAC5029F16922FCA65184F9641793DEBA927A69C68C1D676A
1700832AC572DEF787CA265D5115C6BA2F9432A1581B9DC03993E02FEE08FE9A
0011FED730FBAD6B567CF9F7E930F3D3441C0118808E635DE203EA235242D433
68901FA4AA150BBF2135627039D934227975CF3D19FE98A369ABF290AE3293A0
6BC1BE3194281AC3961FB3A630070643FADBA6805888C9C73DB2B1B394471613
48FDB8DD6E5AB7681CB4AFC5DFAD9F27A7726206400544D6E62673058C36A139
A8F3A2BA3053BA291B945CDC75F78B9DFB53A968601CD129B3EFF01E4C8E3292
AD51E66607815110373BB15465C33057355C1F9D4814C2A082C644D8A8B9302D
F4971F497725959C73C64B3F91CEAB4038D3E69325F596C3618BAF22B4102894
D7FECB5B22B3DD80C9B2F42DEB06F11D09CB49D67ADC4EDBE7D0FEE2BBF3F4D7
897FB76882EA7E83ACEBD9E04D5F6A75A0B3AF865136D7142D75546FDE7FB0B6
8A20EC31CCB54AE0B1324393E117143C8A7A06ACB2CD0B3D94D2526F764C70A8
B622B1D5F265BEBDCA4C5809BBBFC2DD606A076E15D75090D36228DE6B84BC5C
5174C609EE592111ED8B2A325A0B4622F48BD9339C70F1CD5E82EC8690EDE71D
D6A64EFB33389D94E318147F6A5BA8E0365FF91697590777293CE484CA6A5793
2E04E9754231B5AA3A2F6E595CEC5E4A97080AE32BC99DEB8D7CB2AD3C5229E7
5F22DB89FD88EDBEED8DF24719F31E1EE3540BFFEC14217BD7CD2FB8B7A4590B
982A99342BC550BE828EC30D1416E13BE10387222E9C32CDBA7CDE2773D33DC2
64B3E916E18586E8266BADEDAE3325160EC20CD61A22D4B73AF5B7489A208959
14AA987492AC58DB3C95E48CA4A900186638F91CF9827F3A4C9F13DD54A2BDEA
576DA0E89B88C053DF304D32D37C27A823A88C7E731F64C952046A4979871974
6CA7B9C059AFD05E973A530AED81A29474DBCA061EAFBA5EDFC870088A6C2F30
0FD012385735E83C95A0D762483B3F4B16A9AF8995A9EBC28D4C3E04969F904D
2228B88BB67F2D3583F1C14C7C011F6C04D65A058DF74D2269DE27151212F824
EE99E732F1E495996E1336D861BBD264E9FF7A67A4D3402E80E181C041AFCC6A
A27DC87405D973EC136CAFCEC1962FC4ECC6F912AFBFBAF18EBFB1374F91A66E
CDCC4E7F71E60451B66DEA5B7C2CEF7E7CA6505D680AE2C8BFE5235A2C42C58D
E0DCF5F913F1525CECFB82D9A3507A13CF542DC05DD2C84F7A00FEC0D022CA2D
76551A2558DA97A2D4FD7D0EC34D97FB9C85D6282A59DA6C890C3A14B88F85BC
4E3784650506855C2A520E5DF3AC0C70FD112EED0902D562B95EDA174AE8F7F3
2EC024B8B10743DAEC81DE47544A1A5065389EA10D1CAE3B6F03B06A7D14962A
B3EAECF1F90980708385ECD20281B026FE3DA2DA02B8E29DEAB6AFAA970C398B
A295934485AC276D13C2EE3B4507D7A138C8DBF6E1D9CD58B40A6A98646EB229
19AEFCA1803DBB1521E14C3D3D6347AF3ADD3DAB57BE6B65C3FFCD3AE86EADCC
9C67B1A474FF8C0F17DE21E5DDDE8A69795EDF4BF168DC069804421CDDFBCE81
B71940A36764485514F6737DD955FAA65782F211940B3FEA7B5903CC2F2B74F3
0A10668595EA92237B71590D7DFE7C740A841BAF8645897CA9F1CED800E6E3DA
946067AB36256C140651A3DAF4F2B396AD11BE9EC762C09B8EB5905E2915EADB
A052BFB0A3622700E8BAD8CB2261889843A80D5CBC3C3744446E5F2017E48EFB
893C67807AEB7E3E85F27986F9CC90441795A02FFB156ABC2510D52C0CBAB723
1A70DF547A7D9AAACE1054F8AB9CE337A44AA2496F926097BB48698DD73C0ADC
6C17FD9E69C9A20118F68F247F341105B8572E820D16A8933A76322AF205B4F0
E079D7C395031AA5CB38C1AC07507BEDE5E1A2089A6E4F8CFCEBCEACE5ED7096
FE019466013FF3A35A293BC638D5FE7BD1F5B2030B1EF6FBE35D5643A9809E3C
33FE0E10EF203181F6C613B0C2FD8CF5DCA8E641B9E62F233807FE02D40013BC
8881E7B187BB968A95CBD07C4E995363089F0CD16F82A9D3B6654CD14C711F6A
81079760D7FE3F8FB94CCAED44E2288F096DF72F51AC4EFFF0CFE290F3BAF870
C268D553C22F65182FB9A7B785DBD956C8CC71B114E9F0E9892E9DE7080D0F94
18E61282F4177F5FD3FC5B8DDA1ACDD67579D4E194CF69CC57F1E16C81F70EB5
2D99AFEC2587942C287A48F2FDC6C6E035FCE3468FA47B6032A0BDA39BCB021B
5D05901C5532C217BBEEF13F0EA2444BA4E5D559EED9257D2EB6103037F573F6
25CEBF8C946165C8C77D3900CDD491EDEC388A541BDCE06508F99889375F2546
7D6F649A437690547F8C6E3C708335B8E20F5E8FD4EE9D4AA098C078E4D069D3
8871B559FE87ADFAE3118A5D507706EF34C286F43DA369ED8EC13AFDCC4E0DC8
7EB190A2D1C3DF3722FA4F40021CF51B5344C95F48D2E9D294FE13CDE1156CF4
5390BA69A086EC4CD32B612E4D492EE1E79B4731C428721D69F091A9C2F95C71
26498593783878C060DB5D06B272024B4386766DACBD6D9DB5D8EFCBFE55D710
F6EE672D7E084782703B776420709EB42500B44F3FDCFBB4C5FD998CB95DDF86
087D559E8A0CF566D4D7553A23D7EC7B67DEAEEC4C161F6666822745881C7B10
2B08CDE908523D8C8489A2839619BAD6B55106D5F7B6E6DA743D534D2B3AA40C
3BFEBAB0A4B41433EA05112DDB64C58AAC6C57DA67CC2BBF6113974D65354734
8A3A4C96DE04954DC75936B98DC5DF6957C92E44CC565E6DD96B3493D52ED504
9AED4558FBC7CB73C2775F6A52AF8EBDBE52154DDBA36E05ED50F788D3B80D98
219CD1DA582BBC5A841979BEDF5DF2A5806F108914980F1E0206589501984338
A4B62F793D3B5C3EFD8E1BB341EB560C2C5160BFD7AD66A273B762FCF53B13E7
32D16D5CB17AB5C487063F3567483154A01DD054441E8F62DD5D3A70E18DB197
89CF536D92B1EB31D5783525706C8EB3BC64AF19456E100255FF461395388792
D0634CDEAFCD52694E659F983E9D9C3D8DB5BDE5FBC7DE3725E73CAC55F841F3
2795C9FCE256630B89576D4AFB79632E8E971C3F2EAB7F934387002E5A4B5501
C415760193B9D83F1E2CFF1164626A97047C9195A492936199E7436723789457
85C601900112DCAA7B41A905382268941349E1E1947C9729BB83DA427C2D3C04
8058A2D9C3F401C2068C1D2C44AB1F4ACA90CE0C070CC479EFF8A0D27FEF34B6
AF21B1C0E002872DD7CD6FDB9E5C3454C0C4791CB8DC4C0999B3446C55B9456B
A6428E957C65D701A2DB5EF45E5EF39A481750742A375023D30AE210BC77D2DD
32193DF3C6BB9B2D3C59EECDAE98124B07A7064EAE8EA12A274939F96E0ED36C
605FAFA18E04A1606759A92876872B01C3C7015E1E118EC6035F32F745D03339
2B85A628B1CE8F2C4A79FA81FB0D85888E50013EE7935086B9261F67F6945FE8
75B6AFA056DD3F3FFEFE8FE6CEE2EB4896FB219E89A88485B45CAA5BEE2F9984
9D7F7C395EE4779BC0EEBCF3C438699608565EAE932228742358A4E42A093637
12587313A7497A9D3EA598767052B85ED69AAD6D43A3F1D78ED789D8105B9B26
32615853FADF3419BDADB1B3092CDF7C89557AFD97A69D8A023B110267989A20
1A2A556DCA71653CC3D3684406742B6BFEB8352C3B60F47EE4D51D7C6D560462
D70D2D4464896BBDDB0206782FCFFCDBCCCD67D169CC8DA07915969850EF2FA0
8A0FC08876E14A7CB14BC8ED7076C913B86596F6242749D092C011B059D0F735
640BC91B671F0AB8D3CC7F264642BC1652B02F3DB3C476E6AEFE9A0974F6F729
B29DAF5AB23B6E351C89E31348DE096726A99F85A62D4BD2B110EDB0928DC7AA
6C3A7C3070D0C9742120980DFD68AA7FB9149929996D31EA21873AFC
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: CMR12
%!PS-AdobeFont-1.0: CMR12 003.002
%%Title: CMR12
%Version: 003.002
%%CreationDate: Mon Jul 13 16:17:00 2009
%%Creator: David M. Jones
%Copyright: Copyright (c) 1997, 2009 American Mathematical Society
%Copyright: (<http://www.ams.org>), with Reserved Font Name CMR12.
% This Font Software is licensed under the SIL Open Font License, Version 1.1.
% This license is in the accompanying file OFL.txt, and is also
% available with a FAQ at: http://scripts.sil.org/OFL.
%%EndComments
FontDirectory/CMR12 known{/CMR12 findfont dup/UniqueID known{dup
/UniqueID get 5000794 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /CMR12 def
/FontBBox {-34 -251 988 750 }readonly def
/UniqueID 5000794 def
/PaintType 0 def
/FontInfo 9 dict dup begin
/version (003.002) readonly def
/Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMR12.) readonly def
/FullName (CMR12) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 43 /plus put
dup 45 /hyphen put
dup 49 /one put
dup 50 /two put
dup 51 /three put
dup 99 /c put
dup 101 /e put
dup 114 /r put
dup 115 /s put
dup 116 /t put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE3DD325E55798292D7BD972BD75FA
0E079529AF9C82DF72F64195C9C210DCE34528F540DA1FFD7BEBB9B40787BA93
51BBFB7CFC5F9152D1E5BB0AD8D016C6CFA4EB41B3C51D091C2D5440E67CFD71
7C56816B03B901BF4A25A07175380E50A213F877C44778B3C5AADBCC86D6E551
E6AF364B0BFCAAD22D8D558C5C81A7D425A1629DD5182206742D1D082A12F078
0FD4F5F6D3129FCFFF1F4A912B0A7DEC8D33A57B5AE0328EF9D57ADDAC543273
C01924195A181D03F5054A93B71E5065F8D92FE23794D2DB9C535A5E57376651
F6823308463DC4E0339C78699AC82C769542FD3B410E236AF8AF68CF124D9224
FD6EE92A38075CAAF82447C7AF41EF96F3ADF62F76FB425BEDE4C4124E7B1E0B
8BF254D91912D3A99557F5427907A56514C5A3EB961B94112077FE9417B70DA0
B2E1C1FA3E1D6F01D11F640CF848E45BE3E205258E64FE36AFBD4DF4E93F6B1A
966C8E7FBE2CC8FF43C1F67BF6C361678B5E90F4BA524FE8A4CAD6AB28183E6E
CA6C9636E884845105595A2E40CDBE8D4807A81AF4DB77B31873FEB221BCADD4
2C4669459704CB58A7BC230FC59F867EEADE660E49AEEDEEB042BA9A7DD8193E
56C3A36A1F639F7EA512EE4BC6992F52C2FC82A890EFDA730105B0AF7B819295
EE00B48F64C2B5BCB275B1DD62F289CDAD4AD9B7EF057684642FA6FA6322C277
E779CAC36D78F7779CB6DE12638B3C65B70C6B5F8A8C6421A379719B8DD44973
5F52856A4A29B2ED37F2B1FBE6EF4B79B7C0CD6395C756A00FACD763C235914F
847D1D99831023CE1FD89EFEC83AA7E313131C0C197248605EF5BA773D0A4000
72F607551A8EA6F0FF19441ACA179177D1FF7B423FEBDF58B0C19CAE3C10EEF6
3538D8FC4762B77C5AA023A8186C40D0365A4487DC3564265B3DF908572DEAA2
57E29EC669DD72974F806EFF5ECAFA9ADF1F9D2A63087FB7BBD100F0F81C6FFB
B1EA1C9DD46548AEDD147EE64B1B4894972DAE1DC3E8569D6A3CEF9F9E46DEB7
547E10BB2959D374A33E47C58F1B20419920AB485F166062FCCC08EB5CC9AC88
F388F0C0155027B727729488E44CCABB7064A1432E179189C4627453C5231535
47D1F2B8BA43069696830CBB6E5F9A135CF22D3D1FE490A3A63C088EA32FF444
24A2427BBA63033DFE2E06DF8CE67949B6AB02F26335A376B57376814D2A7DE7
64A4347577EBE9A6E33DD2FC214A09C6D889C8FFBF1D567032548851B8F97204
49E215CC7D222F593E1EF1439ED60AD922D41E0E9EFB5CA48F2FEFF75AC5FEE7
FB6676D8B8D4DB6885FBE8B61B586313E4DAFB09D94CEDC0507E93000104F3DD
F83865A2C6F6A7DA8562BF86F5DB233CC9B53391273A1462E40876A8AC2B098A
DBADD5A160DEAC061F86A5FCCAB495EF8A9D121AF07928EAFD56F618E4EAEA97
CF89A3AFD406FC9DE1E9769C1E1EB83BB883786BC075EB5DA2692CD59C4DD7C1
7FD2FF9B18AC740A390C1DB38670DEB18C67721A1DCD502FE7368F47DB4281D5
459B3F020595FA3B10544AAE9EF786A0645FB7C9BB29D091E1432CD878A05918
1665643005BFD9A4B0FFD347ADC84CE22D6F9AD4EDC05E8C7179DCB360AB57D1
6ABCD200A4B4AD56825DC345984D9A3DE11CDA5E9EC1E5006EE4181E4EFE0846
67D8C27BEE8F84A1E01947E945BBE988702DEB2240C4BED952E433E5305484E5
71965D3DE95C4115FF78CE9EC18E323C599727C8B93CDFBCD1CCA780DB8C81ED
C4B5E596E1603624308972FFAE9A57B0EDB51FDDB6E23EDE2946F61BEB241345
2A192D8CAD53E823D687F9C64A70A4B4B703291FA6317C051DC6A44BCCE0288E
3839D726A8F2E39BFF429865E95C726E808E02CD06F36C1CC9AC77999F8E28BF
CE9D74B699CA982479E9D0DD98EAB24D29C981EF0349721D6819549A39413801
F80182D567EE316E2F0AB208068E15693E4C399A381BF9BBA625E597E6E109B8
16F3A84C8EC92F2ADE288821092A421A8D3B907048FE947230810F0777EE2542
29A3485223FEA079B359034F70464DAD2F0E420271A4E0CCF57A0ABBC20AB327
0CA71B292126D395E0D083B19BEC6B48A9DE2BF470C3D01A8C3F52075BD4BE02
A0C518355814478202FD4762EC542F8E7B9B1F7824F0554660CEB83E35635E1E
DF0D03C94C903ECB36B4948ED98B6324E0094EB1DF70863142D4ED3A932D7346
39D69F8F044B6084482D7748C27328AFD24A3A70B99D1F7D32CB984488672254
28B6A9E9DCA2C9FF6A1B311D72413404B3CE5428BDB7FF3C36357D7975184F56
FA6B32AD54C37D0AF7576663AB1397B80D4E998F0B4C4F6D90B483029EF2EDA9
D4C4204C1546EFF3100629453EAE01918D09FE104E626ABA38646F17B6A94CE8
116BC7A8D9C319434CA5B830859B4164DFADF1D7C3ECA5C78D8DEA930EA4AC3F
59DBBF3148C91A2E807FB934E3439D4F67C6DBBA9972854E6E3688E1E0A34B74
482217CFE031CD7B5DFEF727C3EF8DAEEEDA08F4C90289E62FB2AF2357EB2E45
4BC547980FD479101FFEEE477AAC6268DD659E8DD9E244676FD3C6909713B71A
323B211E571BE711D103FA23B5B9AF077D84E2D20FEE805E81D20C03501F0F17
C3B081946CD0FD577F00E50B76CC37CFA97A61B89C25DD43911B28857284BEBB
5BEC61FFE3A14C64BC5425A7A82326617F6F1FA4FEAE56071C9F559F91568179
46369B394A5CE96FB7420FF8AB7C61CB83492FA5AE4A4B0799578594C9EA67E1
E54498AA5CD6ABA34AD3417F04F5D8D664A7EB39D41E2D17643CAEBBCCD9C38C
C5C9541641A09335EFBCE0D276A54253EFD68141807A66F1DFEB4BEA5889FFA3
4D20BD52012206A9F8D3E0F6AFC03FDBBDF3E51506EC6336E249CEFB571AB84C
BDF8E471E3795C04E38A5306BA6D450D72E50910D1AC385BB06CCD4B8E433A32
5A4B7FACC976BB31FCAA1E62DB2C4FE06DDDE7367930E336B49F47DAD91C8735
9A35D80CA2E117E86B52E41E9278046ED923454989E48610ACB3B1663F197117
52659A9D7BFA561C7ACE0771794FC778675F83C5EDCB132AF124C7E6540A140B
E0A268836C73A3C746DC964E482E63C56C0D396515283970FBFF182F9F684FE2
655FD8F5D057D22246DDC3FD11B77552DB4D90ADBAB77BBB1FB1592129DE0AEC
F822D7D36E52BCDABBD560B403A5C56C5E1BE789C3AC049318C7FAC5E5861E42
FD66C3C0F46361078D7E036281682BCE9BBF77983C93ECBBEBA9B359769CA442
87FCA1B98F4EEC4935CC93B08AAADDF355C99816453587310F08C50B9BA3D107
5388A1F3AED2AE32BEFADF0285DA90436D1D7EA85D7B9B6DF2AC4B778CFADFF6
6EEE54D1A1C5DEE3CCA7EFF57A7C2931933CEED90CA26DAAB45E4388EC4DC366
B9E88518D6CF094861D2A59282044CC06E63EFB390A6DF4BA5EAC7CE39E1EE03
3D84099F5BE96612789AF3EDED07266EF10A0FC23EA1EA97040B6BAA63138B1A
A9CB8F5DED781260962D7618EDB200C3ED976033E8967A8CC676E9C11F74BE34
343A7ECE7EE97E8F76F7E95517A6D6163527406EF5A669535CB2BF4031F29046
BB2D0FFFB47A576F5EAB1D00A582965C56F28C00B3BB7BE2CC8D8391F789070D
775EB775437F0CD53DA840BB3575104B63E4B0BF14E3F14B320EDEF65FD4CAF5
8596DA491BBCF3153DED3B718F833D106432DF8DB8B8E6B34D5308C9010A5DD0
7E0E53260BB84BAB3EA748E8D72F75901604F80F4416920D69B4B983DCDB72C5
E9928F01A4A85954FD74578AE336C782CDF81D1EB7EBCEBFBAE7ED8AB4862584
397928F502D65139CCD582CF0723C5262EE54B9D2B8C39614652A8A90E1C3B65
7D26B99DA298FE4B9A7E98848F619C9BB4FF9FD215B72F99506F06355B332689
37D80AFD9F9ACD8172CDC51FCD3A759ACA0F7D4EBB07840840EE42C2D5B8B257
2C6DB3A7657B75F2F0B9730A20112745703E2D0FE709436CA6A5F36F59E64D9E
37C0A23D6D289E1AC1DA273872F5FC5C3DA2B127F078A4D7AB3FD7E124455817
DDC796D54EF26A1FBFD539D3A21B86DD4477DA49213259ABB3FF241424F2BE5F
89151E02FF87E0BEE26E85C0E518D8BE7CC9214B8E9A9EA1DBB49C6C212CCF08
90C0F23E9858947EE344062EBD9C574979087439975EAD4E85CD7BFAD3C91CF1
EFF577843AF1427D06CB2F3BB519ED1591974218C43F0D2038665F9E2E3960B7
FE68CD3CB2DB6B36C7997C6B21EC11CF1DE049541001FFF26D14C255E3AE862C
5A5701292FD2FB3D04523D6E2F3547923BB117718DFB6E6520F0D0B5450C695B
8C9242CC8671B7284CB2E1E9EB097A3DB1B4D5E8EEB93B4DC7E38C0A10474665
54DDCBAF079B92EA494F6FA75A84C5AAFE280284D0823D7C22249A21044BB0E6
4062074ECD17B62E03EDF4945A294BFEFB51F5FD870D9D7230FC91B83C1D85A8
86CDDF326FC90E04362145D6E8630C50594484FB829DA18F5C078F2EE67D2F2B
08DFF39AE2E8C9741FA989AE494C7166F122D2C5F71B97C973B7CE8500E9F87E
D59C30F2E99CC4D34713DAB680598F41955FBDC26A14CF1E73D6BD6B9AAC8D3B
B998F2D0D647356CD236DEAD6561389ED3A6746221B0CF15D6648412B35A6B54
6A0EF5BBB34AA376D9BAF025BFC650C1B74333CE85413D0EBB2F4D082A26A5BC
3C0A25D2B12CB159F140E00E262F1CFECCB2C802FF94CD34DA0CE9B4B3830FB1
DA85B9B670D5169928990A2E9CC869891CA2FFAD9774E6B92549644DAA5FE00C
A5BE4F5FF91A0B6D2FD8F96121D766391EC4ED3E73DADD476B7DAE1A50AFCD98
DB7E27E44D30416088D9BC07D4661D9ECEC0806830ABF14CE55AA3CA2DF66E8E
748B8ED46466F1EEB072AC0674FE6FED231E0DDA59ED7C42BC05EF00E176050A
C4834D893DE42474EA20DB1E25059E84BD137EF65A02CC295B0FFDE4CDE95879
0FE88BDF2519ABAE7F8CC3E6386ED35E04A14F1E3861922645E3A3F43B48A5AA
1999A5EFE192515FCC625C829FF5A7B337AA422F5E920545F9BB269C869A821D
6C4C26DD2AE746EF0F0B4C1E7E9871ADB5270E1CA9BE28225F7A0370D4C52422
E25263EE101C4EC1C7811B05AD42F364844A56BB91EE72FC8ED53CC6954D2BD6
F945D739BE4C61E36143CE890FC0CBF2F610018D678ECF7CEAB18FF5A0E48F76
FDE2463D40A99380D679B3B76D39C664F4992D23E5988B0D1AF33DFB04894016
E852EFD1EFFE586153C0F31ADBDBDE3F73FB49C5EE64D0D02E1504248FAFAC3D
903FD44679BB09C30288139B41B1E90A10139CA3172677250B16535A1F3E5E4B
6F4264DE58896E66051FC677030A121C5A285C47B6129CB5A3998830CE070D21
2F093FC1B44089F603A21F45F60960F134A47226874C737EF6C085634B0A4A66
139420501351F737A73F39D960EC38420BE46E5B09D298E7C16B8E32F01507D4
0141FC52DA1DE718D634AD9C8B00E46EEEF84356759324D2B9A3473C5DA38DE9
E30182B87F91B6A7F7BACF29A93B44C879CCDEDB063F9D2E51E0F1FC9F018FE1
2433D85AF24B55DE3A61C4D0A2DA4FDE933F5F6FDF17E9FA9932BFC46E2D71F6
585EEF5B2E4E89E797A24B799D7F064DD1A817A53677FC9EB8CC3E7F93FE50E8
D50E3191052943FD6C98B573BDD1F6D70349E1F8011599E3F8FDF1D6E80A710E
51E434E85801617C6FD8ACCF1B77B4BFCCDD35CB4C0367F4EB4D8D9DE8284D5E
B4F43E2F8320C2C5A9AE90ECBA7E65D377E91DB69FEF27069235366AD3E126C3
A73CE97F4C90BA00D206FA012C327FD69EE59AF4470A315B1799CDC0539BF90E
512C8FC3BEFE4D1B01D969EA9E3FEF976CD6E0FA4C9ECEC955B265CFD58AB8E5
F7371E479279EE14B689269205C5B506940606CF3E24A1E7EFF3CA96ED30AD6D
E243DE57690C3D69A401AB3315FA49E4BF4ACD4DD1CA39272533E82EFDD508E5
1C2CD286CCC5DE1202C7C7F654521750632EB637F918667E2233A43DF75239EB
F28F3129EB5DEE2FC5BFC331FF709B0FE9B327CBBCE98BCA2C861C6547E50407
1218CEBE6EB5F9BABA4F2E11BCC6FB553A544A567B459E06375102C69F8018DF
BA6A227CFB13E2D74E6A521E01B74F2963E9A0A1C9FD87A88EE6356E3BFABF55
BABC751D2BF85E6712E8EF57914920775906662E4BA68FFA21AD422D34E15578
43CA0568B431101A1194F8AB1EF25E886BFCDFC10F4A5EBD9530816548BC298E
AE4A0B6B52B8B59C644C409B4191B6F4203F52314F2675F02AEB65A72C66E92A
2AC703E15D8D381522C0AC30C165B822A9B8D18CAECC094EDE020756018DCF51
D0701B507519C4270B70D8CE94B436F640C15872F9B5B77892AA3D110E4D6A65
8F0815C61A5127BA25815378683F46E69E54A391A8675977E7DF9C2D4E6FA991
9F029E50CC2F266B31EE9F9F24452D5838905F330CB7E416B8AF836C5AC26AB8
BE2ECC6EA4BDAA08C30995709E225C21D35DB6369167602CBFA8DB2697635925
969002CD1BEE745DA2E56C17EF3F0C05E3847147F86963C37A221C8827195A8A
3D38993E4939AC915BFD9A212F5FF3F826F742B952018986F9FBDDB69C3AC65A
845F7F33C55D4BE60A1817EBBCA7E1538E8087E1BD5C083A320D52953BE65F31
E8339C612A510B59CE48D2EF7061560C4AD258E7DC59694493E3AC878246F37D
6DE89253EBC8830C6B209E818213C4AC4CF1F391AD91D57BE76FB0E2924A1407
E4A949C905E44F54EAED6419F13D59942C8079336A172D4758BEB5D3E786FB93
3CBE4FD2EB53E4E1DAC34E821EB30FD44BC6CB4298242C38F848FC23AEDC9733
52BE6F32E31E25F18301370F8936810B0566B664B042C7AE0D78ACF0A87E5BF6
F9B66E358168B2CEA30DCD940074F3ADB793CDB136161FE2522905E87B8E463F
95D4DAB7E14A3DF7BCCE8141C5A08FCFA2BCE9F2D1B05A7642E75877EB840149
AAB007CD239AE47AD115929427717F219B0A8907F0EC79ADE1B901DAEE87A2F8
39361DAB43DFFF69650F601B24061A9353CFD619FF9626F63275FD09A5B13BB4
8B3379EC4D147C41197E8387FC04DA7BE409524CEF74EA91DC066808A7FD0EF3
957A44E2503EDA67B1C61827479486134E922E560A673BF314D601C66003CD07
55569085AFC8428389A140EB976CCFB8F29E27587E46C413ABE2EFB51AF5913F
53EEB74063162E0BA1E24CEDCA320377D3E11BD374F0B44E132A5C35835B6E2C
D32948EF9DC7931D104C1385709DA882DED6458319F21C2329938396BC074106
CB9CFB9E0A915F8DBC8435F386917AC87A2BA45D857EC30ECA66FB4044F5439E
CDD556B82A0E43418D179AD883C85AC276E1190CEC242E3E1D86E725ADC39E46
BB6C47FE9E17E29F8EA81E870302A00D91434F3B7A05F243176E6EF1082541A1
B9052191EE5C2B8E94A2E02DB65FC769653CA8D1C07A13CB853544AEC7FC35C5
218DE3128AA31952DCE19C55C23FD69BCEA2C661F57B11B8F9E86BFA718D1521
3346E78C701A5E51923D6D937E62FDE3669B214D240538F069A100A542720A86
31DE88116DE775F7ACC2A49EA6C02A24408271A846990669F2AF60AFAB4C16F9
7F4E88E917F0FFDCE68F22998AC0AF2A60A73258C3A4BBC42A2F918123128195
196D0E150D79AC3CF4628503D1F3FC528265ED8324E56849A47B3B07C29940B9
1BC270071E221D355EA51E9942D3BD7F99816304FFFC8F5B036C953B38759341
ED5D7B9C8E6B70C409DD8362FD291201CC385E4A98D73E8518A4C0E544152563
82032FBD2FCB6E403D34B85ED4053A8CB619BDD4DE001F4C3007B1F317579651
E6D6662189CC2D95AB85D7473F65C5D7B4AC63B0FE928F3400035D5A9D443D0D
F3532B99F3AC26CB25EA3CD64C341159061E02EFBC7C033C05CD919BBD827A6A
BAD6DBD2817CD57D7CCC2FAE2B14257C7214981A0678BB213832B04A68AB3631
8B23CA966781ABFCBD46714EEDB6F54568E2E17613658D4F62AAE1B2B4732FA8
F3F9BB87D30D771D591B8E7F59EC319B3C80C7DDB03B26C4A34300BFECE03FD2
8732CB57F2E95555F4EBC6F97D187D7F7BF406499A2B12B953D0AE1984D78EF2
399E862A24DD788C8C23E5A620F4FD4BDD641715A50B543CA1C4DBC2B2F72F6D
19FA0C4EFE4E73FE9669F35AADCBCF96948C6A0F57223555F70B4116FEBF8041
0BD48817C5E2C69174395C9FAA22504E4A4F014CEF38F16D931E1077F8788685
8AF74DC1D5C7DDBBA0E4974CA7890B785D302C38EF46098F42BE6DC19566B7E1
3900E1760FD9347D3B597E451CBA9F7D4EDC10BA86DE1D6874AF11DFF98C0F60
C44F87B52BDA76C2BCEDEDCA09DB6AFF859D1FE4187BBC8C1DEDC1B91AE50250
7D6258635161C89CD9B30317326C3F8547D3A8E869BEAA6D66E69C92A7A3F770
D92F0C60D793DD0238716C7BFE2507A757068A1C9A67CE7747A7F334530FC447
F23BEB6A35278DA7F49F70B3DD1071BFE928C46185A5CE6E7DDB2EEDE3478C06
2F439C3DD54D9F78C2DCD099E02FE7D89A80EB40F20CF53F4ADAF992A5A105C4
D667B9063E1D0F3BCA3376DB65823213DAA2C89079B22600C11A630E04DCE742
B39CE450529A568F66A7730069E21F9B09B93314290ED137CC481ADF3E694FD5
EA95899FCC352B60FBE782556CD8A09AC2C22E68C3024D91188872E3EF5CF22C
B57C7A755CA7EE1641C35A67DD41DDD36913288405ACBC0E387161B07FC71950
ACBD331A9BA2CADD5B05556C803C6BEAAD8443E1962A39FB6C0B3BD84FD08557
3496B0EA379AB91D2B08CC10701AA6CC2D2F1FC6A2AD50CB6A909FD0BD448AF5
E40F3FFC39255E439968EF607D63B3CC4E6517D6F208B87F276C77D365C74032
0A94DCB37953D8CEEB43A206076AD975C68BFFB9153E88990E47CAF7EC7DA14F
A32A7BDBE4EB6EA0F7385C4E7BC1B27E6497EAC9353FB9210080D22AAF90DE76
D16C8F51C7F619C9C239B626063BC4D2A82C0B11E05A18855BF74927A9C23501
A34BB3758E020FD254685D8910C5EEB3F0199F8DCDCE3B1B42EA9D0EE6E0F609
EE496DB8989AFEE0D7AF8031C2C6F7728F2CDEEEFF5D0E271FC0562D8DC8F6D0
230A0B3E5C96986F85D778ACA7ECA065D25DAB434EEFCD498376BBB732FE5F2D
1D97C5299B05B8919A59C8C4863C182A3D02A010BF053ADF13F0925934DA300C
834C5FD5AEDD8B24F596DF4FA78F084CBEBDACADD4AD30621736E09A35F888EC
1690E2224B6FD0D0D2D2D39873C7119EE54A61BB2CA1E2FC40300D9680CC4B04
242F8420385CF4CC0232B96C4825CD0194A8D4E92C8B23BE6FEB882C16AB55F4
BDC0C8AE7EAE11701A1993D2A95792B551DFDEB3CAF02F158AFDCD451047CC65
AFC4B8E6B25824224C1441294F6675D19971B636439F59E22D08D6BF5A997D98
04A98AF02EA65132967281FCD09BDCA000C8F6EA9F7F1B8631A37DBFF50E6442
93F1B1AE4FE70A2AC127AB0B0E636BC4775946BE8F40C48DE5F40DEA9F0A46AC
C1E9D41E7EC30EC5D0D5D299D4878FE38BDACFBBB2BF59FA345ED74D8C8BD6DF
4A7D7CB11F5181EAA531F5BC7D7B51EFA90CA425A1B3AA80A5D066A318B15172
E7E7698F03BC1A26E3E0DC6B59F31B2A531BD0F79397AC08625C202E373E2E4E
846279594E69ABBE7C1FB147DB8D66E772C8852756EA1CF6CFA5AEF764A40725
F83E2F72AA7B1443D87EBB037167238D2792F84B046C0994FAF469047D9E403A
B981B58A2C4E80AF216F1DBF983E0CD0B7DA808FA82BD01BA5DA1F05992A48D7
BBD098610CDF9012DDB73F825CCA49591AA5CD45C1AB5256DA563A922C5A40F9
84BE9CF706D8AAEABF3DDD2B82E8D5CBEF166078937AD9140514463E4AF6F887
BBA833EAE8B55C11B35357761F896C7DBA8856D9A0041D37FAF268E02A9B88CE
8562F80FE9FBCC8171C69526E5EC72E1ED3427F45BB96F06CD88791EB84F949D
EA227AD7BDE5D746114E114ECC2EDFFD7A040F807B495031CB9B373F24E4600B
460E82A2CD32BCA0A0459EC82F997E3C0B8BB30E2C68F9F79257ED7CC300A393
E4128E4BFE0DFD434E51F581219456FC40D06DE344E4534524FF4AC1EA38633C
6FEAE1D58F2BB0AB8EE69F2103128149EEB80C934866573D8A82403331B3F908
CC97015FA6BB8B2A51EC3649376C81B5CCD296279241A93F377950CABF888F61
A0C589332E3979D7F6E7CD31EBBE9223E003F8CAA1D4A6D1A771E1BCA500510A
CD179B8FB85DE99DBC38379FCA14ADFA6574EB28AB0AF988ACC62108F2BF5FE5
E8E0190E5710CE6009D14DB87D0690A109161F8B45D043CA7C4FDD7686BA6347
EFA36DD68367D72F1E47CC83038C242E0CDE70616AB19D9E912DF2DF163915F1
9AD1FC1109E0BD702A067CBF1A2CAC5A14A352B9D135CCA3EB4443BC2E
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
TeXDict begin 39158280 55380996 1000 600 600 (rysunki_2.dvi)
@start /Fa 205[80 50[{}1 119.552 /CMSY10 rf /Fb 149[48
48[96 96 34[134 20[134{}5 172.188 /CMSY10 rf /Fc 134[83
83 115 1[88 61 62 61 83 88 79 88 133 43 2[43 88 79 47
70 1[70 88 79 25[125 1[108 7[124 10[79 79 3[52 3[61 61
40[{}29 172.188 /CMR17 rf /Fd 135[67 9[70 2[61 35[92
2[97 8[33 45[61 13[{}7 119.552 /CMMI12 rf /Fe 139[46
46 46 12[52 1[52 47[59 59 59 3[39 1[91 43[{}10 119.552
/CMR12 rf /Ff 135[96 1[82 10[88 26[109 1[135 2[143 3[133
2[140 121 4[131 2[47 44[75 87 13[{}13 172.188 /CMMI12
rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
%%BeginPaperSize: a4
/setpagedevice where
{ pop << /PageSize [595 842] >> setpagedevice }
{ /a4 where { pop a4 } if }
ifelse
%%EndPaperSize
 end
%%EndSetup
%%Page: 1 1
TeXDict begin 1 0 bop 0 TeXcolorgray Black 0 TeXcolorgray
0 TeXcolorgray 0 TeXcolorgray -243 4147 a
 currentpoint currentpoint translate 0.5 0.5 scale neg exch neg exch
translate
 -243 4147 a
28 w @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   42.67911 85.35823
4.0   1. .setopacityalpha  SD  end
 
@endspecial -215 4147
a
tx@Dict begin  tx@NodeDict begin {42.67911 85.35823 4.0 } false /N@a1
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   42.67911 113.81097
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {42.67911 113.81097 4.0 } false /N@a2
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   42.67911 142.26372
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {42.67911 142.26372 4.0 } false /N@a3
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   42.67911 184.94283
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {42.67911 184.94283 4.0 } false /N@a4
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   71.13185 85.35823
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {71.13185 85.35823 4.0 } false /N@a5
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   71.13185 142.26372
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {71.13185 142.26372 4.0 } false /N@a6
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   71.13185 170.71646
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {71.13185 170.71646 4.0 } false /N@a7
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   71.13185 199.1692
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {71.13185 199.1692 4.0 } false /N@a8
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@a2 /N@a1 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215
4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@a5 /N@a1 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@a2 /N@a3 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147
a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@a3 /N@a4 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@a3 /N@a6 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@a4 /N@a7 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215
4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@a4 /N@a8 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   142.26372 113.81097
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {142.26372 113.81097 4.0 } false /N@b1
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   142.26372 199.1692
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {142.26372 199.1692 4.0 } false /N@b2
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   170.71646 85.35823
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {170.71646 85.35823 4.0 } false /N@b3
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   170.71646 142.26372
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {170.71646 142.26372 4.0 } false /N@b4
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   170.71646 170.71646
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {170.71646 170.71646 4.0 } false /N@b5
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   199.1692 113.81097
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {199.1692 113.81097 4.0 } false /N@b6
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   199.1692 199.1692
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {199.1692 199.1692 4.0 } false /N@b7
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@b3 /N@b1 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215
4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@b4 /N@b1 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@b2 /N@b5 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147
a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@b3 /N@b6 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@b3 /N@b4 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215
4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@b4 /N@b5 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@b4 /N@b6 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147
a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@b5 /N@b7 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   256.07469 113.81097
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {256.07469 113.81097 4.0 } false /N@c1
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   256.07469 199.1692
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {256.07469 199.1692 4.0 } false /N@c2
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   284.52744 85.35823
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {284.52744 85.35823 4.0 } false /N@c3
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   284.52744 142.26372
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {284.52744 142.26372 4.0 } false /N@c4
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   284.52744 170.71646
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {284.52744 170.71646 4.0 } false /N@c5
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   312.98018 113.81097
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {312.98018 113.81097 4.0 } false /N@c6
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   312.98018 199.1692
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {312.98018 199.1692 4.0 } false /N@c7
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@c3 /N@c1 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215
4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@c4 /N@c1 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@c2 /N@c5 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147
a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@c3 /N@c6 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@c4 /N@c5 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@c4 /N@c6 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215
4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@c5 /N@c7 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   398.33841 88.20367
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {398.33841 88.20367 4.0 } false /N@d1
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   455.2439 88.20367
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {455.2439 88.20367 4.0 } false /N@d2
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   369.88567 116.65642
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {369.88567 116.65642 4.0 } false /N@d3
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   398.33841 116.65642
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {398.33841 116.65642 4.0 } false /N@d4
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   455.2439 116.65642
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {455.2439 116.65642 4.0 } false /N@d5
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   483.69664 116.65642
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {483.69664 116.65642 4.0 } false /N@d6
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   426.79115 173.5619
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {426.79115 173.5619 4.0 } false /N@d7
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   405.45158 196.32375
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {405.45158 196.32375 4.0 } false /N@d8
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   448.1307 196.32375
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {448.1307 196.32375 4.0 } false /N@d9
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@d1 /N@d4 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215
4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@d2 /N@d5 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@d3 /N@d4 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147
a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@d4 /N@d5 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@d4 /N@d7 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215
4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@d5 /N@d6 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@d5 /N@d7 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147
a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@d7 /N@d8 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@d7 /N@d9 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   557.67393 88.20367
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {557.67393 88.20367 4.0 } false /N@e1a
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   580.43579 88.20367
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {580.43579 88.20367 4.0 } false /N@e1b
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   614.57942 88.20367
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {614.57942 88.20367 4.0 } false /N@e2a
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   637.34128 88.20367
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {637.34128 88.20367 4.0 } false /N@e2b
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   540.60213 128.03734
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {540.60213 128.03734 4.0 } false /N@e3a
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   540.60213 105.27505
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {540.60213 105.27505 4.0 } false /N@e3b
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   569.05487 116.65642
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {569.05487 116.65642 4.0 } false /N@e4
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   625.96036 116.65642
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {625.96036 116.65642 4.0 } false /N@e5
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   654.4131 128.03734
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {654.4131 128.03734 4.0 } false /N@e6a
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   654.4131 105.27505
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {654.4131 105.27505 4.0 } false /N@e6b
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   597.50761 173.5619
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {597.50761 173.5619 4.0 } false /N@e7
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   564.78712 176.40692
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {564.78712 176.40692 4.0 } false /N@e8a
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   576.16805 196.32375
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {576.16805 196.32375 4.0 } false /N@e8b
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   630.22809 176.40692
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {630.22809 176.40692 4.0 } false /N@e9a
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   618.84717 196.32375
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {618.84717 196.32375 4.0 } false /N@e9b
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@e1a /N@e4 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215
4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@e1b /N@e4 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@e1a /N@e1b InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147
a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@e2a /N@e5 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@e2b /N@e5 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215
4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@e2b /N@e2a InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@e3a /N@e4 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147
a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@e3b /N@e4 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@e3a /N@e3b InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@e4 /N@e5 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215
4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@e4 /N@e7 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@e5 /N@e6a InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147
a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@e5 /N@e6b InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@e6b /N@e6a InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215
4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@e5 /N@e7 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@e7 /N@e8a InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147
a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@e7 /N@e8b InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@e8b /N@e8a InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@e7 /N@e9a InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215
4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@e7 /N@e9b InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@e9a /N@e9b InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147
a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   711.31859 113.81097
4.0   1. .setopacityalpha  SD  end
 
@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {711.31859 113.81097 4.0 } false /N@f1
11 {InitCnode } /NodeScale {} def NewNode end  end

-215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   739.77133 85.35823
4.0   1. .setopacityalpha  SD  end
 
@endspecial -215
4147 a
tx@Dict begin  tx@NodeDict begin {739.77133 85.35823 4.0 } false /N@f3
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   739.77133 142.26372
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {739.77133 142.26372 4.0 } false /N@f4
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   739.77133 170.71646
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {739.77133 170.71646 4.0 } false /N@f5
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   768.22408 113.81097
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {768.22408 113.81097 4.0 } false /N@f6
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   707.05084 176.40692
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {707.05084 176.40692 4.0 } false /N@f2a
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   718.43176 196.32375
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {718.43176 196.32375 4.0 } false /N@f2b
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   772.4918 176.40692
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {772.4918 176.40692 4.0 } false /N@f7a
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   761.11089 196.32375
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {761.11089 196.32375 4.0 } false /N@f7b
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@f3 /N@f1 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215
4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@f4 /N@f1 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@f2a /N@f5 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147
a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@f2b /N@f5 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@f2a /N@f2b InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@f3 /N@f6 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215
4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@f4 /N@f5 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@f4 /N@f6 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147
a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@f5 /N@f7a InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@f5 /N@f7b InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215
4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@f7a /N@f7b InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   825.12956 119.50143
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {825.12956 119.50143 4.0 } false /N@g1
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   825.12956 165.02599
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {825.12956 165.02599 4.0 } false /N@g2
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   853.5823 85.35823
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {853.5823 85.35823 4.0 } false /N@g3
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   853.5823 199.1692
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {853.5823 199.1692 4.0 } false /N@g4
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   882.03505 119.50143
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {882.03505 119.50143 4.0 } false /N@g5
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   882.03505 165.02599
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {882.03505 165.02599 4.0 } false /N@g6
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@g3 /N@g1 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215
4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@g1 /N@g2 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@g2 /N@g4 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147
a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@g3 /N@g5 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@g4 /N@g6 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@g5 /N@g6 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinecap [  4.0  4.0 ] 0 0 add  DashLine  grestore  grestore
end
 -215
4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   938.94054 85.35823
4.0   1. .setopacityalpha  SD  end
 
@endspecial -215 4147
a
tx@Dict begin  tx@NodeDict begin {938.94054 85.35823 4.0 } false /N@h1
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   938.94054 156.49008
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {938.94054 156.49008 4.0 } false /N@h2
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   967.39328 199.1692
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {967.39328 199.1692 4.0 } false /N@h3
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   995.84602 85.35823
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {995.84602 85.35823 4.0 } false /N@h4
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   995.84602 156.49008
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {995.84602 156.49008 4.0 } false /N@h5
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@h4 /N@h1 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215
4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@h1 /N@h2 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@h2 /N@h3 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147
a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@h3 /N@h5 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@h5 /N@h4 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinecap [  4.0  4.0 ] 0 0 add  DashLine  grestore  grestore
end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   199.1692 441.01752
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {199.1692 441.01752 4.0 } false /N@i1
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   199.1692 497.923
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {199.1692 497.923 4.0 } false /N@i2
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   227.62195 469.47026
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {227.62195 469.47026 4.0 } false /N@i3
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   256.07469 441.01752
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {256.07469 441.01752 4.0 } false /N@i4
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   256.07469 497.923
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {256.07469 497.923 4.0 } false /N@i5
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   284.52744 469.47026
4.0   1. .setopacityalpha  SD  end


@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {284.52744 469.47026 4.0 } false /N@i6
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@i3 /N@i1 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215
4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@i2 /N@i3 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@i3 /N@i4 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147
a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@i3 /N@i5 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@i4 /N@i5 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215
4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@i4 /N@i6 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@i6 /N@i5 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   682.86584 298.7538
4.0   1. .setopacityalpha  SD  end
 
@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {682.86584 298.7538 4.0 } false /N@j1
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   682.86584 355.65929
4.0   1. .setopacityalpha  SD  end
 
@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {682.86584 355.65929 4.0 } false /N@j2
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   711.31859 327.20654
4.0   1. .setopacityalpha  SD  end
 
@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {711.31859 327.20654 4.0 } false /N@j3
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   739.77133 298.7538
4.0   1. .setopacityalpha  SD  end
 
@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {739.77133 298.7538 4.0 } false /N@j4
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   739.77133 355.65929
4.0   1. .setopacityalpha  SD  end
 
@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {739.77133 355.65929 4.0 } false /N@j5
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   768.22408 327.20654
4.0   1. .setopacityalpha  SD  end
 
@endspecial -215 4147 a
tx@Dict begin  tx@NodeDict begin {768.22408 327.20654 4.0 } false /N@j6
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a -215
4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@j3 /N@j1 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@j2 /N@j1 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147
a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@j2 /N@j3 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@j3 /N@j4 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@j3 /N@j5 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215
4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@j4 /N@j5 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@j4 /N@j6 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147
a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@j6 /N@j5 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   199.1692 327.20654
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {199.1692 327.20654 4.0 } false /N@x1
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   227.62195 327.20654
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {227.62195 327.20654 4.0 } false /N@x2
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   256.07469 327.20654
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {256.07469 327.20654 4.0 } false /N@x3
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   284.52744 298.7538
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {284.52744 298.7538 4.0 } false /N@x4
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   284.52744 327.20654
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {284.52744 327.20654 4.0 } false /N@x5
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   341.43292 298.7538
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {341.43292 298.7538 4.0 } false /N@x6
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   341.43292 327.20654
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {341.43292 327.20654 4.0 } false /N@x7
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   369.88567 298.7538
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {369.88567 298.7538 4.0 } false /N@x8
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   369.88567 355.65929
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {369.88567 355.65929 4.0 } false /N@x9
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   398.33841 327.20654
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {398.33841 327.20654 4.0 } false /N@x10
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@x2 /N@x1 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215
4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@x2 /N@x3 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@x3 /N@x5 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147
a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@x4 /N@x5 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@x4 /N@x6 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@x4 /N@x7 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215
4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@x5 /N@x7 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@x6 /N@x7 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147
a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@x8 /N@x7 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@x9 /N@x7 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215
4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@x8 /N@x9 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@x8 /N@x10 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147
a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@x9 /N@x10 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   739.77133 441.01752
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {739.77133 441.01752 4.0 } false /N@k1
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   739.77133 497.923
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {739.77133 497.923 4.0 } false /N@k2
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   768.22408 441.01752
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {768.22408 441.01752 4.0 } false /N@k3a
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   768.22408 497.923
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {768.22408 497.923 4.0 } false /N@k3b
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   796.67682 441.01752
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {796.67682 441.01752 4.0 } false /N@k4
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   796.67682 497.923
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {796.67682 497.923 4.0 } false /N@k5
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray   825.12956 469.47026
4.0   1. .setopacityalpha  SD  end
 
@endspecial
-215 4147 a
tx@Dict begin  tx@NodeDict begin {825.12956 469.47026 4.0 } false /N@k6
11 {InitCnode } /NodeScale {} def NewNode end  end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@k3a /N@k1 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215
4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@k2 /N@k1 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinecap [  4.0  4.0 ] 0 0 add  DashLine  grestore  grestore
end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@k2 /N@k3b InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147
a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@k5 /N@k3b InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@k5 /N@k6 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@k6 /N@k4 InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215
4147 a -215 4147 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { }
def  0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@k4 /N@k3a InitNC
{ NCLine  } if end  gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore  grestore end
 -215 4147 a -215 4147 a
tx@Dict begin { 775.33725 469.47026 } PutCoor PutBegin  end
 -215 4147
a -414 4188 a Ff(C)-293 4214 y Fe(3)p Fd(k)t Fe(+1)-215
4147 y
tx@Dict begin  PutEnd  end
 -215 4147 a -215 4147 a
tx@Dict begin { 839.35593 441.01752 } PutCoor PutBegin  end
 -215 4147 a -414 4190
a Fc(cycles)-215 4147 y
tx@Dict begin  PutEnd  end
 -215 4147 a -215 4147 a
tx@Dict begin { 938.94054 469.47026 } PutCoor PutBegin  end
 -215
4147 a -692 4182 a Fc(bipartite)51 b Ff(K)96 4208 y Fe(2)p
Fd(;n)-215 4147 y
tx@Dict begin  PutEnd  end
 -215 4147 a -215 4147 a
tx@Dict begin { 853.5823 142.26372 } PutCoor PutBegin  end
 -215 4147 a
-339 4193 a Ff(C)-218 4219 y Fe(3)p Fd(k)-215 4147 y
tx@Dict begin  PutEnd  end

-215 4147 a -215 4147 a
tx@Dict begin { 853.5823 56.90549 } PutCoor PutBegin  end
 -215 4147 a -414 4190 a Fc(cycles)-215
4147 y
tx@Dict begin  PutEnd  end
 -215 4147 a -215 4147 a
tx@Dict begin { 967.39328 128.03734 } PutCoor PutBegin  end
 -215 4147 a -414 4188
a Ff(C)-293 4214 y Fe(3)p Fd(k)t Fe(+2)-215 4147 y
tx@Dict begin  PutEnd  end
 -215
4147 a -215 4147 a
tx@Dict begin { 967.39328 56.90549 } PutCoor PutBegin  end
 -215 4147 a -414 4190 a Fc(cycles)-215
4147 y
tx@Dict begin  PutEnd  end
 -215 4147 a -215 4147 a
tx@Dict begin { 426.79115 42.67911 } PutCoor PutBegin  end
 -215 4147 a -548 4190
a Fc(paths)h Ff(P)-9 4216 y Fe(3)p Fd(k)-215 4147 y
tx@Dict begin  PutEnd  end
 -215
4147 a -215 4147 a
tx@Dict begin { 56.90549 14.22636 } PutCoor PutBegin  end
 -215 4147 a -623 4189 a Fc(paths)g
Ff(P)-84 4215 y Fe(3)p Fd(k)t Fe(+2)-215 4147 y
tx@Dict begin  PutEnd  end
 -215
4147 a -215 4147 a
tx@Dict begin { 85.35823 483.69664 } PutCoor PutBegin  end
 -215 4147 a -623 4189 a Fc(paths)g
Ff(P)-84 4215 y Fe(3)p Fd(k)t Fe(+1)-215 4147 y
tx@Dict begin  PutEnd  end
 -215
4147 a -215 4147 a
tx@Dict begin { 85.35823 455.2439 } PutCoor PutBegin  end
 -215 4147 a -477 4190 a Fc(\()p Ff(k)h
Fb(\025)48 b Fc(2\))-215 4147 y
tx@Dict begin  PutEnd  end
 -215 4147 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  [ -7.11317
-85.35823 -7.11317 526.37575 1031.41194 526.37575 1031.41194 -85.35823
-7.11317 -85.35823    /Lineto /lineto load def 0  setlinejoin false
Line  gsave 0.75 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial -215 4147 a
tx@Dict begin { 512.14938 547.7153 } PutCoor PutBegin  end
 -215 4147 a -1890
4190 a Fc(Examples)53 b(of)f(graphs)g Ff(G)g Fc(for)g(whic)l(h)g
Ff(\015)9 b Fc(\()p Ff(G)p Fc(\))48 b(=)g Ff(\015)1050
4216 y Fe(cer)1204 4190 y Fc(\()p Ff(G)p Fc(\))-215 4147
y
tx@Dict begin  PutEnd  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  [ 512.14938
526.37575 512.14938 -85.35823    /Lineto /lineto load def 0  setlinejoin
false Line  gsave 0.75 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
-215 4147 a
tx@Dict begin { 441.01752 505.0362 } PutCoor PutBegin  end
 -215 4147 a -533 4190 a Ff(\016)6 b Fc(\()p
Ff(G)p Fc(\))48 b(=)g(1)-215 4147 y
tx@Dict begin  PutEnd  end
 -215 4147 a -215
4147 a
tx@Dict begin { 583.28123 505.0362 } PutCoor PutBegin  end
 -215 4147 a -538 4190 a Ff(\016)6 b Fc(\()p Ff(G)p
Fc(\))48 b Fb(\025)g Fc(2)-215 4147 y
tx@Dict begin  PutEnd  end
 -215 4147 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.75 SLW 1  setgray  /ArrowA { moveto } def /ArrowB { } def  [ 483.69664
-22.76227 483.69664 5.69046 540.60213 5.69046 540.60213 -22.76227 483.69664
-22.76227    /Lineto /lineto load def 0  setlinejoin false Line  gsave
1  setgray  1. .setopacityalpha  fill  grestore gsave 0.75 SLW 1  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial -215 4147 a
tx@Dict begin { 512.14938 -9.95863 } PutCoor PutBegin  end
 -215 4147 a -1329
4187 a Fb(9)-1233 4213 y Fd(\015)7 b Fe(-set)37 b Fd(D)-788
4187 y Fb(8)-692 4213 y Fd(x)p Fa(2)p Fd(D)-338 4187
y Ff(\015)9 b Fc(\()p Ff(G)39 b Fb(\000)g Ff(x)p Fc(\))47
b Ff(>)h(\015)9 b Fc(\()p Ff(G)p Fc(\))-215 4147 y
tx@Dict begin  PutEnd  end
 -215
4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  [ 341.43292
-28.45274 341.43292 227.62195 682.86584 227.62195 682.86584 -28.45274
341.43292 -28.45274    /Lineto /lineto load def 0  setlinejoin false
Line  gsave 0.75 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.75 SLW 1  setgray  /ArrowA { moveto } def /ArrowB { } def  [ 483.69664
231.88968 483.69664 257.4974 540.60213 257.4974 540.60213 231.88968
483.69664 231.88968    /Lineto /lineto load def 0  setlinejoin false
Line  gsave 1  setgray  1. .setopacityalpha  fill  grestore gsave 0.75
SLW 1  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  [ 227.62195
-35.56592 227.62195 263.18787 796.67682 263.18787 796.67682 -35.56592
227.62195 -35.56592    /Lineto /lineto load def 0  setlinejoin false
Line  gsave 0.75 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
-215 4147 a
tx@Dict begin { 512.14938 244.69376 } PutCoor PutBegin  end
 -215 4147 a -1130 4190 a Fc(Graphs)52 b(with)g(unique)g
Ff(\015)9 b Fc(-sets)-215 4147 y
tx@Dict begin  PutEnd  end
 -215 4147 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.75 SLW 1  setgray  /ArrowA { moveto } def /ArrowB { } def  [ 483.69664
381.26659 483.69664 406.87431 540.60213 406.87431 540.60213 381.26659
483.69664 381.26659    /Lineto /lineto load def 0  setlinejoin false
Line  gsave 1  setgray  1. .setopacityalpha  fill  grestore gsave 0.75
SLW 1  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial -215 4147 a
tx@Dict begin { 500.76845 392.64793 } PutCoor PutBegin  end
 -215 4147 a -1310
4187 a Fb(9)-1214 4213 y Fd(\015)e Fe(-set)38 b Fd(D)-769
4187 y Fb(8)-673 4213 y Fd(x)p Fa(2)p Fd(D)-318 4187
y Fb(j)p Ff(P)23 b(N)-3 4213 y Fd(G)93 4187 y Fc(\()p
Ff(v)6 b(;)28 b(D)5 b Fc(\))p Fb(j)48 b(\025)f Fc(2)-215
4147 y
tx@Dict begin  PutEnd  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  [ 113.81097
-42.67911 113.81097 412.56477 910.4878 412.56477 910.4878 -42.67911
113.81097 -42.67911    /Lineto /lineto load def 0  setlinejoin false
Line  gsave 0.75 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.75 SLW 1  setgray  /ArrowA { moveto } def /ArrowB { } def  [ 483.69664
-73.9773 483.69664 -48.36957 540.60213 -48.36957 540.60213 -73.9773
483.69664 -73.9773    /Lineto /lineto load def 0  setlinejoin false
Line  gsave 1  setgray  1. .setopacityalpha  fill  grestore gsave 0.75
SLW 1  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial -215 4147 a
tx@Dict begin { 512.14938 -61.17322 } PutCoor PutBegin  end
 -215
4147 a -1331 4187 a Fb(8)-1235 4213 y Fd(\015)7 b Fe(-set)38
b Fd(D)-790 4187 y Fb(8)-694 4213 y Fd(x)p Fa(2)p Fd(D)-339
4187 y Ff(\015)9 b Fc(\()p Ff(G)39 b Fb(\000)f Ff(x)p
Fc(\))48 b Fb(\025)g Ff(\015)9 b Fc(\()p Ff(G)p Fc(\))-215
4147 y
tx@Dict begin  PutEnd  end
 -215 4147 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.75 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  [ 0.0
-78.24504 0.0 270.30106 1024.29877 270.30106 1024.29877 -78.24504 0.0
-78.24504    /Lineto /lineto load def 0  setlinejoin false Line  gsave
0.75 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
-243 4147 a
 currentpoint currentpoint translate 1 0.5 div 1 0.5 div scale neg
exch neg exch translate
 -243 4147 a Black 0 TeXcolorgray Black eop
end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
